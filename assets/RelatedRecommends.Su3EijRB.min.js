import {
    Q as R,
    R as B,
    bq as L,
    r as O,
    j as y,
    h as j,
    P as at,
    d1 as lt,
    n as Z,
    bF as se,
    t as X,
    f as F,
    l as ot,
    o as De,
    U as dt,
    q as ye,
    p as ct,
    z as ut,
    au as ft
} from "./app.BSN4W8HM.min.js";
import {
    B as pt
} from "./BlurImg.4lbVpDr4.min.js";
import {
    H as de,
    N as ht
} from "./NovelReviewScore.BA_adrvz.min.js";
import {
    u as ze,
    N as Me
} from "./useNovelStatus.BH42DY_K.min.js";
import {
    g as Ae
} from "./path.CF9Kc7wv.min.js";

function mt() {
    const e = R(B.downSm2),
        n = R(B.onlySm2),
        t = R(B.onlyMd),
        i = R(B.upLg, {
            defaultMatches: !0
        }),
        s = R(B.upMd);
    return {
        isMobile: e,
        isTablet: n,
        isDesktop: t,
        isLargeScreen: i,
        isUpMd: s
    }
}

function _e(e) {
    return e !== null && typeof e == "object" && "constructor" in e && e.constructor === Object
}

function Ee(e = {}, n = {}) {
    Object.keys(n).forEach(t => {
        typeof e[t] > "u" ? e[t] = n[t] : _e(n[t]) && _e(e[t]) && Object.keys(n[t]).length > 0 && Ee(e[t], n[t])
    })
}
const Be = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};

function z() {
    const e = typeof document < "u" ? document : {};
    return Ee(e, Be), e
}
const gt = {
    document: Be,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(e) {
        return typeof setTimeout > "u" ? (e(), null) : setTimeout(e, 0)
    },
    cancelAnimationFrame(e) {
        typeof setTimeout > "u" || clearTimeout(e)
    }
};

function N() {
    const e = typeof window < "u" ? window : {};
    return Ee(e, gt), e
}

function vt(e) {
    const n = e.__proto__;
    Object.defineProperty(e, "__proto__", {
        get() {
            return n
        },
        set(t) {
            n.__proto__ = t
        }
    })
}
class W extends Array {
    constructor(n) {
        typeof n == "number" ? super(n) : (super(...n || []), vt(this))
    }
}

function re(e = []) {
    const n = [];
    return e.forEach(t => {
        Array.isArray(t) ? n.push(...re(t)) : n.push(t)
    }), n
}

function Re(e, n) {
    return Array.prototype.filter.call(e, n)
}

function bt(e) {
    const n = [];
    for (let t = 0; t < e.length; t += 1) n.indexOf(e[t]) === -1 && n.push(e[t]);
    return n
}

function St(e, n) {
    if (typeof e != "string") return [e];
    const t = [],
        i = n.querySelectorAll(e);
    for (let s = 0; s < i.length; s += 1) t.push(i[s]);
    return t
}

function x(e, n) {
    const t = N(),
        i = z();
    let s = [];
    if (!n && e instanceof W) return e;
    if (!e) return new W(s);
    if (typeof e == "string") {
        const r = e.trim();
        if (r.indexOf("<") >= 0 && r.indexOf(">") >= 0) {
            let l = "div";
            r.indexOf("<li") === 0 && (l = "ul"), r.indexOf("<tr") === 0 && (l = "tbody"), (r.indexOf("<td") === 0 || r.indexOf("<th") === 0) && (l = "tr"), r.indexOf("<tbody") === 0 && (l = "table"), r.indexOf("<option") === 0 && (l = "select");
            const d = i.createElement(l);
            d.innerHTML = r;
            for (let a = 0; a < d.childNodes.length; a += 1) s.push(d.childNodes[a])
        } else s = St(e.trim(), n || i)
    } else if (e.nodeType || e === t || e === i) s.push(e);
    else if (Array.isArray(e)) {
        if (e instanceof W) return e;
        s = e
    }
    return new W(bt(s))
}
x.fn = W.prototype;

function xt(...e) {
    const n = re(e.map(t => t.split(" ")));
    return this.forEach(t => {
        t.classList.add(...n)
    }), this
}

function Tt(...e) {
    const n = re(e.map(t => t.split(" ")));
    return this.forEach(t => {
        t.classList.remove(...n)
    }), this
}

function Ct(...e) {
    const n = re(e.map(t => t.split(" ")));
    this.forEach(t => {
        n.forEach(i => {
            t.classList.toggle(i)
        })
    })
}

function Et(...e) {
    const n = re(e.map(t => t.split(" ")));
    return Re(this, t => n.filter(i => t.classList.contains(i)).length > 0).length > 0
}

function wt(e, n) {
    if (arguments.length === 1 && typeof e == "string") return this[0] ? this[0].getAttribute(e) : void 0;
    for (let t = 0; t < this.length; t += 1)
        if (arguments.length === 2) this[t].setAttribute(e, n);
        else
            for (const i in e) this[t][i] = e[i], this[t].setAttribute(i, e[i]);
    return this
}

function yt(e) {
    for (let n = 0; n < this.length; n += 1) this[n].removeAttribute(e);
    return this
}

function Mt(e) {
    for (let n = 0; n < this.length; n += 1) this[n].style.transform = e;
    return this
}

function _t(e) {
    for (let n = 0; n < this.length; n += 1) this[n].style.transitionDuration = typeof e != "string" ? `${e}ms` : e;
    return this
}

function $t(...e) {
    let [n, t, i, s] = e;
    typeof e[1] == "function" && ([n, i, s] = e, t = void 0), s || (s = !1);

    function r(o) {
        const c = o.target;
        if (!c) return;
        const f = o.target.dom7EventData || [];
        if (f.indexOf(o) < 0 && f.unshift(o), x(c).is(t)) i.apply(c, f);
        else {
            const u = x(c).parents();
            for (let g = 0; g < u.length; g += 1) x(u[g]).is(t) && i.apply(u[g], f)
        }
    }

    function l(o) {
        const c = o && o.target ? o.target.dom7EventData || [] : [];
        c.indexOf(o) < 0 && c.unshift(o), i.apply(this, c)
    }
    const d = n.split(" ");
    let a;
    for (let o = 0; o < this.length; o += 1) {
        const c = this[o];
        if (t)
            for (a = 0; a < d.length; a += 1) {
                const f = d[a];
                c.dom7LiveListeners || (c.dom7LiveListeners = {}), c.dom7LiveListeners[f] || (c.dom7LiveListeners[f] = []), c.dom7LiveListeners[f].push({
                    listener: i,
                    proxyListener: r
                }), c.addEventListener(f, r, s)
            } else
                for (a = 0; a < d.length; a += 1) {
                    const f = d[a];
                    c.dom7Listeners || (c.dom7Listeners = {}), c.dom7Listeners[f] || (c.dom7Listeners[f] = []), c.dom7Listeners[f].push({
                        listener: i,
                        proxyListener: l
                    }), c.addEventListener(f, l, s)
                }
    }
    return this
}

function Ot(...e) {
    let [n, t, i, s] = e;
    typeof e[1] == "function" && ([n, i, s] = e, t = void 0), s || (s = !1);
    const r = n.split(" ");
    for (let l = 0; l < r.length; l += 1) {
        const d = r[l];
        for (let a = 0; a < this.length; a += 1) {
            const o = this[a];
            let c;
            if (!t && o.dom7Listeners ? c = o.dom7Listeners[d] : t && o.dom7LiveListeners && (c = o.dom7LiveListeners[d]), c && c.length)
                for (let f = c.length - 1; f >= 0; f -= 1) {
                    const u = c[f];
                    i && u.listener === i || i && u.listener && u.listener.dom7proxy && u.listener.dom7proxy === i ? (o.removeEventListener(d, u.proxyListener, s), c.splice(f, 1)) : i || (o.removeEventListener(d, u.proxyListener, s), c.splice(f, 1))
                }
        }
    }
    return this
}

function Pt(...e) {
    const n = N(),
        t = e[0].split(" "),
        i = e[1];
    for (let s = 0; s < t.length; s += 1) {
        const r = t[s];
        for (let l = 0; l < this.length; l += 1) {
            const d = this[l];
            if (n.CustomEvent) {
                const a = new n.CustomEvent(r, {
                    detail: i,
                    bubbles: !0,
                    cancelable: !0
                });
                d.dom7EventData = e.filter((o, c) => c > 0), d.dispatchEvent(a), d.dom7EventData = [], delete d.dom7EventData
            }
        }
    }
    return this
}

function kt(e) {
    const n = this;

    function t(i) {
        i.target === this && (e.call(this, i), n.off("transitionend", t))
    }
    return e && n.on("transitionend", t), this
}

function Lt(e) {
    if (this.length > 0) {
        if (e) {
            const n = this.styles();
            return this[0].offsetWidth + parseFloat(n.getPropertyValue("margin-right")) + parseFloat(n.getPropertyValue("margin-left"))
        }
        return this[0].offsetWidth
    }
    return null
}

function Nt(e) {
    if (this.length > 0) {
        if (e) {
            const n = this.styles();
            return this[0].offsetHeight + parseFloat(n.getPropertyValue("margin-top")) + parseFloat(n.getPropertyValue("margin-bottom"))
        }
        return this[0].offsetHeight
    }
    return null
}

function It() {
    if (this.length > 0) {
        const e = N(),
            n = z(),
            t = this[0],
            i = t.getBoundingClientRect(),
            s = n.body,
            r = t.clientTop || s.clientTop || 0,
            l = t.clientLeft || s.clientLeft || 0,
            d = t === e ? e.scrollY : t.scrollTop,
            a = t === e ? e.scrollX : t.scrollLeft;
        return {
            top: i.top + d - r,
            left: i.left + a - l
        }
    }
    return null
}

function Dt() {
    const e = N();
    return this[0] ? e.getComputedStyle(this[0], null) : {}
}

function zt(e, n) {
    const t = N();
    let i;
    if (arguments.length === 1)
        if (typeof e == "string") {
            if (this[0]) return t.getComputedStyle(this[0], null).getPropertyValue(e)
        } else {
            for (i = 0; i < this.length; i += 1)
                for (const s in e) this[i].style[s] = e[s];
            return this
        }
    if (arguments.length === 2 && typeof e == "string") {
        for (i = 0; i < this.length; i += 1) this[i].style[e] = n;
        return this
    }
    return this
}

function At(e) {
    return e ? (this.forEach((n, t) => {
        e.apply(n, [n, t])
    }), this) : this
}

function Bt(e) {
    const n = Re(this, e);
    return x(n)
}

function Rt(e) {
    if (typeof e > "u") return this[0] ? this[0].innerHTML : null;
    for (let n = 0; n < this.length; n += 1) this[n].innerHTML = e;
    return this
}

function Gt(e) {
    if (typeof e > "u") return this[0] ? this[0].textContent.trim() : null;
    for (let n = 0; n < this.length; n += 1) this[n].textContent = e;
    return this
}

function Ht(e) {
    const n = N(),
        t = z(),
        i = this[0];
    let s, r;
    if (!i || typeof e > "u") return !1;
    if (typeof e == "string") {
        if (i.matches) return i.matches(e);
        if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e);
        if (i.msMatchesSelector) return i.msMatchesSelector(e);
        for (s = x(e), r = 0; r < s.length; r += 1)
            if (s[r] === i) return !0;
        return !1
    }
    if (e === t) return i === t;
    if (e === n) return i === n;
    if (e.nodeType || e instanceof W) {
        for (s = e.nodeType ? [e] : e, r = 0; r < s.length; r += 1)
            if (s[r] === i) return !0;
        return !1
    }
    return !1
}

function Vt() {
    let e = this[0],
        n;
    if (e) {
        for (n = 0;
            (e = e.previousSibling) !== null;) e.nodeType === 1 && (n += 1);
        return n
    }
}

function Ft(e) {
    if (typeof e > "u") return this;
    const n = this.length;
    if (e > n - 1) return x([]);
    if (e < 0) {
        const t = n + e;
        return t < 0 ? x([]) : x([this[t]])
    }
    return x([this[e]])
}

function jt(...e) {
    let n;
    const t = z();
    for (let i = 0; i < e.length; i += 1) {
        n = e[i];
        for (let s = 0; s < this.length; s += 1)
            if (typeof n == "string") {
                const r = t.createElement("div");
                for (r.innerHTML = n; r.firstChild;) this[s].appendChild(r.firstChild)
            } else if (n instanceof W)
            for (let r = 0; r < n.length; r += 1) this[s].appendChild(n[r]);
        else this[s].appendChild(n)
    }
    return this
}

function Wt(e) {
    const n = z();
    let t, i;
    for (t = 0; t < this.length; t += 1)
        if (typeof e == "string") {
            const s = n.createElement("div");
            for (s.innerHTML = e, i = s.childNodes.length - 1; i >= 0; i -= 1) this[t].insertBefore(s.childNodes[i], this[t].childNodes[0])
        } else if (e instanceof W)
        for (i = 0; i < e.length; i += 1) this[t].insertBefore(e[i], this[t].childNodes[0]);
    else this[t].insertBefore(e, this[t].childNodes[0]);
    return this
}

function Yt(e) {
    return this.length > 0 ? e ? this[0].nextElementSibling && x(this[0].nextElementSibling).is(e) ? x([this[0].nextElementSibling]) : x([]) : this[0].nextElementSibling ? x([this[0].nextElementSibling]) : x([]) : x([])
}

function qt(e) {
    const n = [];
    let t = this[0];
    if (!t) return x([]);
    for (; t.nextElementSibling;) {
        const i = t.nextElementSibling;
        e ? x(i).is(e) && n.push(i) : n.push(i), t = i
    }
    return x(n)
}

function Xt(e) {
    if (this.length > 0) {
        const n = this[0];
        return e ? n.previousElementSibling && x(n.previousElementSibling).is(e) ? x([n.previousElementSibling]) : x([]) : n.previousElementSibling ? x([n.previousElementSibling]) : x([])
    }
    return x([])
}

function Ut(e) {
    const n = [];
    let t = this[0];
    if (!t) return x([]);
    for (; t.previousElementSibling;) {
        const i = t.previousElementSibling;
        e ? x(i).is(e) && n.push(i) : n.push(i), t = i
    }
    return x(n)
}

function Kt(e) {
    const n = [];
    for (let t = 0; t < this.length; t += 1) this[t].parentNode !== null && (e ? x(this[t].parentNode).is(e) && n.push(this[t].parentNode) : n.push(this[t].parentNode));
    return x(n)
}

function Qt(e) {
    const n = [];
    for (let t = 0; t < this.length; t += 1) {
        let i = this[t].parentNode;
        for (; i;) e ? x(i).is(e) && n.push(i) : n.push(i), i = i.parentNode
    }
    return x(n)
}

function Jt(e) {
    let n = this;
    return typeof e > "u" ? x([]) : (n.is(e) || (n = n.parents(e).eq(0)), n)
}

function Zt(e) {
    const n = [];
    for (let t = 0; t < this.length; t += 1) {
        const i = this[t].querySelectorAll(e);
        for (let s = 0; s < i.length; s += 1) n.push(i[s])
    }
    return x(n)
}

function en(e) {
    const n = [];
    for (let t = 0; t < this.length; t += 1) {
        const i = this[t].children;
        for (let s = 0; s < i.length; s += 1)(!e || x(i[s]).is(e)) && n.push(i[s])
    }
    return x(n)
}

function tn() {
    for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);
    return this
}
const $e = {
    addClass: xt,
    removeClass: Tt,
    hasClass: Et,
    toggleClass: Ct,
    attr: wt,
    removeAttr: yt,
    transform: Mt,
    transition: _t,
    on: $t,
    off: Ot,
    trigger: Pt,
    transitionEnd: kt,
    outerWidth: Lt,
    outerHeight: Nt,
    styles: Dt,
    offset: It,
    css: zt,
    each: At,
    html: Rt,
    text: Gt,
    is: Ht,
    index: Vt,
    eq: Ft,
    append: jt,
    prepend: Wt,
    next: Yt,
    nextAll: qt,
    prev: Xt,
    prevAll: Ut,
    parent: Kt,
    parents: Qt,
    closest: Jt,
    find: Zt,
    children: en,
    filter: Bt,
    remove: tn
};
Object.keys($e).forEach(e => {
    Object.defineProperty(x.fn, e, {
        value: $e[e],
        writable: !0
    })
});

function nn(e) {
    const n = e;
    Object.keys(n).forEach(t => {
        try {
            n[t] = null
        } catch {}
        try {
            delete n[t]
        } catch {}
    })
}

function Se(e, n = 0) {
    return setTimeout(e, n)
}

function q() {
    return Date.now()
}

function sn(e) {
    const n = N();
    let t;
    return n.getComputedStyle && (t = n.getComputedStyle(e, null)), !t && e.currentStyle && (t = e.currentStyle), t || (t = e.style), t
}

function rn(e, n = "x") {
    const t = N();
    let i, s, r;
    const l = sn(e);
    return t.WebKitCSSMatrix ? (s = l.transform || l.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(d => d.replace(",", ".")).join(", ")), r = new t.WebKitCSSMatrix(s === "none" ? "" : s)) : (r = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = r.toString().split(",")), n === "x" && (t.WebKitCSSMatrix ? s = r.m41 : i.length === 16 ? s = parseFloat(i[12]) : s = parseFloat(i[4])), n === "y" && (t.WebKitCSSMatrix ? s = r.m42 : i.length === 16 ? s = parseFloat(i[13]) : s = parseFloat(i[5])), s || 0
}

function le(e) {
    return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object"
}

function an(e) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? e instanceof HTMLElement : e && (e.nodeType === 1 || e.nodeType === 11)
}

function A(...e) {
    const n = Object(e[0]),
        t = ["__proto__", "constructor", "prototype"];
    for (let i = 1; i < e.length; i += 1) {
        const s = e[i];
        if (s != null && !an(s)) {
            const r = Object.keys(Object(s)).filter(l => t.indexOf(l) < 0);
            for (let l = 0, d = r.length; l < d; l += 1) {
                const a = r[l],
                    o = Object.getOwnPropertyDescriptor(s, a);
                o !== void 0 && o.enumerable && (le(n[a]) && le(s[a]) ? s[a].__swiper__ ? n[a] = s[a] : A(n[a], s[a]) : !le(n[a]) && le(s[a]) ? (n[a] = {}, s[a].__swiper__ ? n[a] = s[a] : A(n[a], s[a])) : n[a] = s[a])
            }
        }
    }
    return n
}

function oe(e, n, t) {
    e.style.setProperty(n, t)
}

function Ge({
    swiper: e,
    targetPosition: n,
    side: t
}) {
    const i = N(),
        s = -e.translate;
    let r = null,
        l;
    const d = e.params.speed;
    e.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(e.cssModeFrameID);
    const a = n > s ? "next" : "prev",
        o = (f, u) => a === "next" && f >= u || a === "prev" && f <= u,
        c = () => {
            l = new Date().getTime(), r === null && (r = l);
            const f = Math.max(Math.min((l - r) / d, 1), 0),
                u = .5 - Math.cos(f * Math.PI) / 2;
            let g = s + u * (n - s);
            if (o(g, n) && (g = n), e.wrapperEl.scrollTo({
                    [t]: g
                }), o(g, n)) {
                e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                    e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
                        [t]: g
                    })
                }), i.cancelAnimationFrame(e.cssModeFrameID);
                return
            }
            e.cssModeFrameID = i.requestAnimationFrame(c)
        };
    c()
}
let pe;

function ln() {
    const e = N(),
        n = z();
    return {
        smoothScroll: n.documentElement && "scrollBehavior" in n.documentElement.style,
        touch: !!("ontouchstart" in e || e.DocumentTouch && n instanceof e.DocumentTouch),
        passiveListener: function() {
            let i = !1;
            try {
                const s = Object.defineProperty({}, "passive", {
                    get() {
                        i = !0
                    }
                });
                e.addEventListener("testPassiveListener", null, s)
            } catch {}
            return i
        }(),
        gestures: function() {
            return "ongesturestart" in e
        }()
    }
}

function He() {
    return pe || (pe = ln()), pe
}
let he;

function on({
    userAgent: e
} = {}) {
    const n = He(),
        t = N(),
        i = t.navigator.platform,
        s = e || t.navigator.userAgent,
        r = {
            ios: !1,
            android: !1
        },
        l = t.screen.width,
        d = t.screen.height,
        a = s.match(/(Android);?[\s\/]+([\d.]+)?/);
    let o = s.match(/(iPad).*OS\s([\d_]+)/);
    const c = s.match(/(iPod)(.*OS\s([\d_]+))?/),
        f = !o && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
        u = i === "Win32";
    let g = i === "MacIntel";
    const v = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !o && g && n.touch && v.indexOf(`${l}x${d}`) >= 0 && (o = s.match(/(Version)\/([\d.]+)/), o || (o = [0, 1, "13_0_0"]), g = !1), a && !u && (r.os = "android", r.android = !0), (o || f || c) && (r.os = "ios", r.ios = !0), r
}

function dn(e = {}) {
    return he || (he = on(e)), he
}
let me;

function cn() {
    const e = N();

    function n() {
        const t = e.navigator.userAgent.toLowerCase();
        return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
    }
    return {
        isSafari: n(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
    }
}

function un() {
    return me || (me = cn()), me
}

function fn({
    swiper: e,
    on: n,
    emit: t
}) {
    const i = N();
    let s = null,
        r = null;
    const l = () => {
            !e || e.destroyed || !e.initialized || (t("beforeResize"), t("resize"))
        },
        d = () => {
            !e || e.destroyed || !e.initialized || (s = new ResizeObserver(c => {
                r = i.requestAnimationFrame(() => {
                    const {
                        width: f,
                        height: u
                    } = e;
                    let g = f,
                        v = u;
                    c.forEach(({
                        contentBoxSize: p,
                        contentRect: h,
                        target: m
                    }) => {
                        m && m !== e.el || (g = h ? h.width : (p[0] || p).inlineSize, v = h ? h.height : (p[0] || p).blockSize)
                    }), (g !== f || v !== u) && l()
                })
            }), s.observe(e.el))
        },
        a = () => {
            r && i.cancelAnimationFrame(r), s && s.unobserve && e.el && (s.unobserve(e.el), s = null)
        },
        o = () => {
            !e || e.destroyed || !e.initialized || t("orientationchange")
        };
    n("init", () => {
        if (e.params.resizeObserver && typeof i.ResizeObserver < "u") {
            d();
            return
        }
        i.addEventListener("resize", l), i.addEventListener("orientationchange", o)
    }), n("destroy", () => {
        a(), i.removeEventListener("resize", l), i.removeEventListener("orientationchange", o)
    })
}

function pn({
    swiper: e,
    extendParams: n,
    on: t,
    emit: i
}) {
    const s = [],
        r = N(),
        l = (o, c = {}) => {
            const f = r.MutationObserver || r.WebkitMutationObserver,
                u = new f(g => {
                    if (g.length === 1) {
                        i("observerUpdate", g[0]);
                        return
                    }
                    const v = function() {
                        i("observerUpdate", g[0])
                    };
                    r.requestAnimationFrame ? r.requestAnimationFrame(v) : r.setTimeout(v, 0)
                });
            u.observe(o, {
                attributes: typeof c.attributes > "u" ? !0 : c.attributes,
                childList: typeof c.childList > "u" ? !0 : c.childList,
                characterData: typeof c.characterData > "u" ? !0 : c.characterData
            }), s.push(u)
        },
        d = () => {
            if (e.params.observer) {
                if (e.params.observeParents) {
                    const o = e.$el.parents();
                    for (let c = 0; c < o.length; c += 1) l(o[c])
                }
                l(e.$el[0], {
                    childList: e.params.observeSlideChildren
                }), l(e.$wrapperEl[0], {
                    attributes: !1
                })
            }
        },
        a = () => {
            s.forEach(o => {
                o.disconnect()
            }), s.splice(0, s.length)
        };
    n({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }), t("init", d), t("destroy", a)
}
const hn = {
    on(e, n, t) {
        const i = this;
        if (!i.eventsListeners || i.destroyed || typeof n != "function") return i;
        const s = t ? "unshift" : "push";
        return e.split(" ").forEach(r => {
            i.eventsListeners[r] || (i.eventsListeners[r] = []), i.eventsListeners[r][s](n)
        }), i
    },
    once(e, n, t) {
        const i = this;
        if (!i.eventsListeners || i.destroyed || typeof n != "function") return i;

        function s(...r) {
            i.off(e, s), s.__emitterProxy && delete s.__emitterProxy, n.apply(i, r)
        }
        return s.__emitterProxy = n, i.on(e, s, t)
    },
    onAny(e, n) {
        const t = this;
        if (!t.eventsListeners || t.destroyed || typeof e != "function") return t;
        const i = n ? "unshift" : "push";
        return t.eventsAnyListeners.indexOf(e) < 0 && t.eventsAnyListeners[i](e), t
    },
    offAny(e) {
        const n = this;
        if (!n.eventsListeners || n.destroyed || !n.eventsAnyListeners) return n;
        const t = n.eventsAnyListeners.indexOf(e);
        return t >= 0 && n.eventsAnyListeners.splice(t, 1), n
    },
    off(e, n) {
        const t = this;
        return !t.eventsListeners || t.destroyed || !t.eventsListeners || e.split(" ").forEach(i => {
            typeof n > "u" ? t.eventsListeners[i] = [] : t.eventsListeners[i] && t.eventsListeners[i].forEach((s, r) => {
                (s === n || s.__emitterProxy && s.__emitterProxy === n) && t.eventsListeners[i].splice(r, 1)
            })
        }), t
    },
    emit(...e) {
        const n = this;
        if (!n.eventsListeners || n.destroyed || !n.eventsListeners) return n;
        let t, i, s;
        return typeof e[0] == "string" || Array.isArray(e[0]) ? (t = e[0], i = e.slice(1, e.length), s = n) : (t = e[0].events, i = e[0].data, s = e[0].context || n), i.unshift(s), (Array.isArray(t) ? t : t.split(" ")).forEach(l => {
            n.eventsAnyListeners && n.eventsAnyListeners.length && n.eventsAnyListeners.forEach(d => {
                d.apply(s, [l, ...i])
            }), n.eventsListeners && n.eventsListeners[l] && n.eventsListeners[l].forEach(d => {
                d.apply(s, i)
            })
        }), n
    }
};

function mn() {
    const e = this;
    let n, t;
    const i = e.$el;
    typeof e.params.width < "u" && e.params.width !== null ? n = e.params.width : n = i[0].clientWidth, typeof e.params.height < "u" && e.params.height !== null ? t = e.params.height : t = i[0].clientHeight, !(n === 0 && e.isHorizontal() || t === 0 && e.isVertical()) && (n = n - parseInt(i.css("padding-left") || 0, 10) - parseInt(i.css("padding-right") || 0, 10), t = t - parseInt(i.css("padding-top") || 0, 10) - parseInt(i.css("padding-bottom") || 0, 10), Number.isNaN(n) && (n = 0), Number.isNaN(t) && (t = 0), Object.assign(e, {
        width: n,
        height: t,
        size: e.isHorizontal() ? n : t
    }))
}

function gn() {
    const e = this;

    function n(w) {
        return e.isHorizontal() ? w : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[w]
    }

    function t(w, E) {
        return parseFloat(w.getPropertyValue(n(E)) || 0)
    }
    const i = e.params,
        {
            $wrapperEl: s,
            size: r,
            rtlTranslate: l,
            wrongRTL: d
        } = e,
        a = e.virtual && i.virtual.enabled,
        o = a ? e.virtual.slides.length : e.slides.length,
        c = s.children(`.${e.params.slideClass}`),
        f = a ? e.virtual.slides.length : c.length;
    let u = [];
    const g = [],
        v = [];
    let p = i.slidesOffsetBefore;
    typeof p == "function" && (p = i.slidesOffsetBefore.call(e));
    let h = i.slidesOffsetAfter;
    typeof h == "function" && (h = i.slidesOffsetAfter.call(e));
    const m = e.snapGrid.length,
        b = e.slidesGrid.length;
    let S = i.spaceBetween,
        C = -p,
        T = 0,
        M = 0;
    if (typeof r > "u") return;
    typeof S == "string" && S.indexOf("%") >= 0 && (S = parseFloat(S.replace("%", "")) / 100 * r), e.virtualSize = -S, l ? c.css({
        marginLeft: "",
        marginBottom: "",
        marginTop: ""
    }) : c.css({
        marginRight: "",
        marginBottom: "",
        marginTop: ""
    }), i.centeredSlides && i.cssMode && (oe(e.wrapperEl, "--swiper-centered-offset-before", ""), oe(e.wrapperEl, "--swiper-centered-offset-after", ""));
    const P = i.grid && i.grid.rows > 1 && e.grid;
    P && e.grid.initSlides(f);
    let $;
    const I = i.slidesPerView === "auto" && i.breakpoints && Object.keys(i.breakpoints).filter(w => typeof i.breakpoints[w].slidesPerView < "u").length > 0;
    for (let w = 0; w < f; w += 1) {
        $ = 0;
        const E = c.eq(w);
        if (P && e.grid.updateSlide(w, E, f, n), E.css("display") !== "none") {
            if (i.slidesPerView === "auto") {
                I && (c[w].style[n("width")] = "");
                const _ = getComputedStyle(E[0]),
                    k = E[0].style.transform,
                    K = E[0].style.webkitTransform;
                if (k && (E[0].style.transform = "none"), K && (E[0].style.webkitTransform = "none"), i.roundLengths) $ = e.isHorizontal() ? E.outerWidth(!0) : E.outerHeight(!0);
                else {
                    const te = t(_, "width"),
                        ue = t(_, "padding-left"),
                        fe = t(_, "padding-right"),
                        ae = t(_, "margin-left"),
                        D = t(_, "margin-right"),
                        Q = _.getPropertyValue("box-sizing");
                    if (Q && Q === "border-box") $ = te + ae + D;
                    else {
                        const {
                            clientWidth: st,
                            offsetWidth: rt
                        } = E[0];
                        $ = te + ue + fe + ae + D + (rt - st)
                    }
                }
                k && (E[0].style.transform = k), K && (E[0].style.webkitTransform = K), i.roundLengths && ($ = Math.floor($))
            } else $ = (r - (i.slidesPerView - 1) * S) / i.slidesPerView, i.roundLengths && ($ = Math.floor($)), c[w] && (c[w].style[n("width")] = `${$}px`);
            c[w] && (c[w].swiperSlideSize = $), v.push($), i.centeredSlides ? (C = C + $ / 2 + T / 2 + S, T === 0 && w !== 0 && (C = C - r / 2 - S), w === 0 && (C = C - r / 2 - S), Math.abs(C) < 1 / 1e3 && (C = 0), i.roundLengths && (C = Math.floor(C)), M % i.slidesPerGroup === 0 && u.push(C), g.push(C)) : (i.roundLengths && (C = Math.floor(C)), (M - Math.min(e.params.slidesPerGroupSkip, M)) % e.params.slidesPerGroup === 0 && u.push(C), g.push(C), C = C + $ + S), e.virtualSize += $ + S, T = $, M += 1
        }
    }
    if (e.virtualSize = Math.max(e.virtualSize, r) + h, l && d && (i.effect === "slide" || i.effect === "coverflow") && s.css({
            width: `${e.virtualSize+i.spaceBetween}px`
        }), i.setWrapperSize && s.css({
            [n("width")]: `${e.virtualSize+i.spaceBetween}px`
        }), P && e.grid.updateWrapperSize($, u, n), !i.centeredSlides) {
        const w = [];
        for (let E = 0; E < u.length; E += 1) {
            let _ = u[E];
            i.roundLengths && (_ = Math.floor(_)), u[E] <= e.virtualSize - r && w.push(_)
        }
        u = w, Math.floor(e.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - r)
    }
    if (u.length === 0 && (u = [0]), i.spaceBetween !== 0) {
        const w = e.isHorizontal() && l ? "marginLeft" : n("marginRight");
        c.filter((E, _) => i.cssMode ? _ !== c.length - 1 : !0).css({
            [w]: `${S}px`
        })
    }
    if (i.centeredSlides && i.centeredSlidesBounds) {
        let w = 0;
        v.forEach(_ => {
            w += _ + (i.spaceBetween ? i.spaceBetween : 0)
        }), w -= i.spaceBetween;
        const E = w - r;
        u = u.map(_ => _ < 0 ? -p : _ > E ? E + h : _)
    }
    if (i.centerInsufficientSlides) {
        let w = 0;
        if (v.forEach(E => {
                w += E + (i.spaceBetween ? i.spaceBetween : 0)
            }), w -= i.spaceBetween, w < r) {
            const E = (r - w) / 2;
            u.forEach((_, k) => {
                u[k] = _ - E
            }), g.forEach((_, k) => {
                g[k] = _ + E
            })
        }
    }
    if (Object.assign(e, {
            slides: c,
            snapGrid: u,
            slidesGrid: g,
            slidesSizesGrid: v
        }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
        oe(e.wrapperEl, "--swiper-centered-offset-before", `${-u[0]}px`), oe(e.wrapperEl, "--swiper-centered-offset-after", `${e.size/2-v[v.length-1]/2}px`);
        const w = -e.snapGrid[0],
            E = -e.slidesGrid[0];
        e.snapGrid = e.snapGrid.map(_ => _ + w), e.slidesGrid = e.slidesGrid.map(_ => _ + E)
    }
    if (f !== o && e.emit("slidesLengthChange"), u.length !== m && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), g.length !== b && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), !a && !i.cssMode && (i.effect === "slide" || i.effect === "fade")) {
        const w = `${i.containerModifierClass}backface-hidden`,
            E = e.$el.hasClass(w);
        f <= i.maxBackfaceHiddenSlides ? E || e.$el.addClass(w) : E && e.$el.removeClass(w)
    }
}

function vn(e) {
    const n = this,
        t = [],
        i = n.virtual && n.params.virtual.enabled;
    let s = 0,
        r;
    typeof e == "number" ? n.setTransition(e) : e === !0 && n.setTransition(n.params.speed);
    const l = d => i ? n.slides.filter(a => parseInt(a.getAttribute("data-swiper-slide-index"), 10) === d)[0] : n.slides.eq(d)[0];
    if (n.params.slidesPerView !== "auto" && n.params.slidesPerView > 1)
        if (n.params.centeredSlides)(n.visibleSlides || x([])).each(d => {
            t.push(d)
        });
        else
            for (r = 0; r < Math.ceil(n.params.slidesPerView); r += 1) {
                const d = n.activeIndex + r;
                if (d > n.slides.length && !i) break;
                t.push(l(d))
            } else t.push(l(n.activeIndex));
    for (r = 0; r < t.length; r += 1)
        if (typeof t[r] < "u") {
            const d = t[r].offsetHeight;
            s = d > s ? d : s
        }(s || s === 0) && n.$wrapperEl.css("height", `${s}px`)
}

function bn() {
    const e = this,
        n = e.slides;
    for (let t = 0; t < n.length; t += 1) n[t].swiperSlideOffset = e.isHorizontal() ? n[t].offsetLeft : n[t].offsetTop
}

function Sn(e = this && this.translate || 0) {
    const n = this,
        t = n.params,
        {
            slides: i,
            rtlTranslate: s,
            snapGrid: r
        } = n;
    if (i.length === 0) return;
    typeof i[0].swiperSlideOffset > "u" && n.updateSlidesOffset();
    let l = -e;
    s && (l = e), i.removeClass(t.slideVisibleClass), n.visibleSlidesIndexes = [], n.visibleSlides = [];
    for (let d = 0; d < i.length; d += 1) {
        const a = i[d];
        let o = a.swiperSlideOffset;
        t.cssMode && t.centeredSlides && (o -= i[0].swiperSlideOffset);
        const c = (l + (t.centeredSlides ? n.minTranslate() : 0) - o) / (a.swiperSlideSize + t.spaceBetween),
            f = (l - r[0] + (t.centeredSlides ? n.minTranslate() : 0) - o) / (a.swiperSlideSize + t.spaceBetween),
            u = -(l - o),
            g = u + n.slidesSizesGrid[d];
        (u >= 0 && u < n.size - 1 || g > 1 && g <= n.size || u <= 0 && g >= n.size) && (n.visibleSlides.push(a), n.visibleSlidesIndexes.push(d), i.eq(d).addClass(t.slideVisibleClass)), a.progress = s ? -c : c, a.originalProgress = s ? -f : f
    }
    n.visibleSlides = x(n.visibleSlides)
}

function xn(e) {
    const n = this;
    if (typeof e > "u") {
        const o = n.rtlTranslate ? -1 : 1;
        e = n && n.translate && n.translate * o || 0
    }
    const t = n.params,
        i = n.maxTranslate() - n.minTranslate();
    let {
        progress: s,
        isBeginning: r,
        isEnd: l
    } = n;
    const d = r,
        a = l;
    i === 0 ? (s = 0, r = !0, l = !0) : (s = (e - n.minTranslate()) / i, r = s <= 0, l = s >= 1), Object.assign(n, {
        progress: s,
        isBeginning: r,
        isEnd: l
    }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && n.updateSlidesProgress(e), r && !d && n.emit("reachBeginning toEdge"), l && !a && n.emit("reachEnd toEdge"), (d && !r || a && !l) && n.emit("fromEdge"), n.emit("progress", s)
}

function Tn() {
    const e = this,
        {
            slides: n,
            params: t,
            $wrapperEl: i,
            activeIndex: s,
            realIndex: r
        } = e,
        l = e.virtual && t.virtual.enabled;
    n.removeClass(`${t.slideActiveClass} ${t.slideNextClass} ${t.slidePrevClass} ${t.slideDuplicateActiveClass} ${t.slideDuplicateNextClass} ${t.slideDuplicatePrevClass}`);
    let d;
    l ? d = e.$wrapperEl.find(`.${t.slideClass}[data-swiper-slide-index="${s}"]`) : d = n.eq(s), d.addClass(t.slideActiveClass), t.loop && (d.hasClass(t.slideDuplicateClass) ? i.children(`.${t.slideClass}:not(.${t.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(t.slideDuplicateActiveClass) : i.children(`.${t.slideClass}.${t.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(t.slideDuplicateActiveClass));
    let a = d.nextAll(`.${t.slideClass}`).eq(0).addClass(t.slideNextClass);
    t.loop && a.length === 0 && (a = n.eq(0), a.addClass(t.slideNextClass));
    let o = d.prevAll(`.${t.slideClass}`).eq(0).addClass(t.slidePrevClass);
    t.loop && o.length === 0 && (o = n.eq(-1), o.addClass(t.slidePrevClass)), t.loop && (a.hasClass(t.slideDuplicateClass) ? i.children(`.${t.slideClass}:not(.${t.slideDuplicateClass})[data-swiper-slide-index="${a.attr("data-swiper-slide-index")}"]`).addClass(t.slideDuplicateNextClass) : i.children(`.${t.slideClass}.${t.slideDuplicateClass}[data-swiper-slide-index="${a.attr("data-swiper-slide-index")}"]`).addClass(t.slideDuplicateNextClass), o.hasClass(t.slideDuplicateClass) ? i.children(`.${t.slideClass}:not(.${t.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(t.slideDuplicatePrevClass) : i.children(`.${t.slideClass}.${t.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(t.slideDuplicatePrevClass)), e.emitSlidesClasses()
}

function Cn(e) {
    const n = this,
        t = n.rtlTranslate ? n.translate : -n.translate,
        {
            slidesGrid: i,
            snapGrid: s,
            params: r,
            activeIndex: l,
            realIndex: d,
            snapIndex: a
        } = n;
    let o = e,
        c;
    if (typeof o > "u") {
        for (let u = 0; u < i.length; u += 1) typeof i[u + 1] < "u" ? t >= i[u] && t < i[u + 1] - (i[u + 1] - i[u]) / 2 ? o = u : t >= i[u] && t < i[u + 1] && (o = u + 1) : t >= i[u] && (o = u);
        r.normalizeSlideIndex && (o < 0 || typeof o > "u") && (o = 0)
    }
    if (s.indexOf(t) >= 0) c = s.indexOf(t);
    else {
        const u = Math.min(r.slidesPerGroupSkip, o);
        c = u + Math.floor((o - u) / r.slidesPerGroup)
    }
    if (c >= s.length && (c = s.length - 1), o === l) {
        c !== a && (n.snapIndex = c, n.emit("snapIndexChange"));
        return
    }
    const f = parseInt(n.slides.eq(o).attr("data-swiper-slide-index") || o, 10);
    Object.assign(n, {
        snapIndex: c,
        realIndex: f,
        previousIndex: l,
        activeIndex: o
    }), n.emit("activeIndexChange"), n.emit("snapIndexChange"), d !== f && n.emit("realIndexChange"), (n.initialized || n.params.runCallbacksOnInit) && n.emit("slideChange")
}

function En(e) {
    const n = this,
        t = n.params,
        i = x(e).closest(`.${t.slideClass}`)[0];
    let s = !1,
        r;
    if (i) {
        for (let l = 0; l < n.slides.length; l += 1)
            if (n.slides[l] === i) {
                s = !0, r = l;
                break
            }
    }
    if (i && s) n.clickedSlide = i, n.virtual && n.params.virtual.enabled ? n.clickedIndex = parseInt(x(i).attr("data-swiper-slide-index"), 10) : n.clickedIndex = r;
    else {
        n.clickedSlide = void 0, n.clickedIndex = void 0;
        return
    }
    t.slideToClickedSlide && n.clickedIndex !== void 0 && n.clickedIndex !== n.activeIndex && n.slideToClickedSlide()
}
const wn = {
    updateSize: mn,
    updateSlides: gn,
    updateAutoHeight: vn,
    updateSlidesOffset: bn,
    updateSlidesProgress: Sn,
    updateProgress: xn,
    updateSlidesClasses: Tn,
    updateActiveIndex: Cn,
    updateClickedSlide: En
};

function yn(e = this.isHorizontal() ? "x" : "y") {
    const n = this,
        {
            params: t,
            rtlTranslate: i,
            translate: s,
            $wrapperEl: r
        } = n;
    if (t.virtualTranslate) return i ? -s : s;
    if (t.cssMode) return s;
    let l = rn(r[0], e);
    return i && (l = -l), l || 0
}

function Mn(e, n) {
    const t = this,
        {
            rtlTranslate: i,
            params: s,
            $wrapperEl: r,
            wrapperEl: l,
            progress: d
        } = t;
    let a = 0,
        o = 0;
    const c = 0;
    t.isHorizontal() ? a = i ? -e : e : o = e, s.roundLengths && (a = Math.floor(a), o = Math.floor(o)), s.cssMode ? l[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -a : -o : s.virtualTranslate || r.transform(`translate3d(${a}px, ${o}px, ${c}px)`), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? a : o;
    let f;
    const u = t.maxTranslate() - t.minTranslate();
    u === 0 ? f = 0 : f = (e - t.minTranslate()) / u, f !== d && t.updateProgress(e), t.emit("setTranslate", t.translate, n)
}

function _n() {
    return -this.snapGrid[0]
}

function $n() {
    return -this.snapGrid[this.snapGrid.length - 1]
}

function On(e = 0, n = this.params.speed, t = !0, i = !0, s) {
    const r = this,
        {
            params: l,
            wrapperEl: d
        } = r;
    if (r.animating && l.preventInteractionOnTransition) return !1;
    const a = r.minTranslate(),
        o = r.maxTranslate();
    let c;
    if (i && e > a ? c = a : i && e < o ? c = o : c = e, r.updateProgress(c), l.cssMode) {
        const f = r.isHorizontal();
        if (n === 0) d[f ? "scrollLeft" : "scrollTop"] = -c;
        else {
            if (!r.support.smoothScroll) return Ge({
                swiper: r,
                targetPosition: -c,
                side: f ? "left" : "top"
            }), !0;
            d.scrollTo({
                [f ? "left" : "top"]: -c,
                behavior: "smooth"
            })
        }
        return !0
    }
    return n === 0 ? (r.setTransition(0), r.setTranslate(c), t && (r.emit("beforeTransitionStart", n, s), r.emit("transitionEnd"))) : (r.setTransition(n), r.setTranslate(c), t && (r.emit("beforeTransitionStart", n, s), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(u) {
        !r || r.destroyed || u.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, t && r.emit("transitionEnd"))
    }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0
}
const Pn = {
    getTranslate: yn,
    setTranslate: Mn,
    minTranslate: _n,
    maxTranslate: $n,
    translateTo: On
};

function kn(e, n) {
    const t = this;
    t.params.cssMode || t.$wrapperEl.transition(e), t.emit("setTransition", e, n)
}

function Ve({
    swiper: e,
    runCallbacks: n,
    direction: t,
    step: i
}) {
    const {
        activeIndex: s,
        previousIndex: r
    } = e;
    let l = t;
    if (l || (s > r ? l = "next" : s < r ? l = "prev" : l = "reset"), e.emit(`transition${i}`), n && s !== r) {
        if (l === "reset") {
            e.emit(`slideResetTransition${i}`);
            return
        }
        e.emit(`slideChangeTransition${i}`), l === "next" ? e.emit(`slideNextTransition${i}`) : e.emit(`slidePrevTransition${i}`)
    }
}

function Ln(e = !0, n) {
    const t = this,
        {
            params: i
        } = t;
    i.cssMode || (i.autoHeight && t.updateAutoHeight(), Ve({
        swiper: t,
        runCallbacks: e,
        direction: n,
        step: "Start"
    }))
}

function Nn(e = !0, n) {
    const t = this,
        {
            params: i
        } = t;
    t.animating = !1, !i.cssMode && (t.setTransition(0), Ve({
        swiper: t,
        runCallbacks: e,
        direction: n,
        step: "End"
    }))
}
const In = {
    setTransition: kn,
    transitionStart: Ln,
    transitionEnd: Nn
};

function Dn(e = 0, n = this.params.speed, t = !0, i, s) {
    if (typeof e != "number" && typeof e != "string") throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);
    if (typeof e == "string") {
        const S = parseInt(e, 10);
        if (!isFinite(S)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
        e = S
    }
    const r = this;
    let l = e;
    l < 0 && (l = 0);
    const {
        params: d,
        snapGrid: a,
        slidesGrid: o,
        previousIndex: c,
        activeIndex: f,
        rtlTranslate: u,
        wrapperEl: g,
        enabled: v
    } = r;
    if (r.animating && d.preventInteractionOnTransition || !v && !i && !s) return !1;
    const p = Math.min(r.params.slidesPerGroupSkip, l);
    let h = p + Math.floor((l - p) / r.params.slidesPerGroup);
    h >= a.length && (h = a.length - 1);
    const m = -a[h];
    if (d.normalizeSlideIndex)
        for (let S = 0; S < o.length; S += 1) {
            const C = -Math.floor(m * 100),
                T = Math.floor(o[S] * 100),
                M = Math.floor(o[S + 1] * 100);
            typeof o[S + 1] < "u" ? C >= T && C < M - (M - T) / 2 ? l = S : C >= T && C < M && (l = S + 1) : C >= T && (l = S)
        }
    if (r.initialized && l !== f && (!r.allowSlideNext && m < r.translate && m < r.minTranslate() || !r.allowSlidePrev && m > r.translate && m > r.maxTranslate() && (f || 0) !== l)) return !1;
    l !== (c || 0) && t && r.emit("beforeSlideChangeStart"), r.updateProgress(m);
    let b;
    if (l > f ? b = "next" : l < f ? b = "prev" : b = "reset", u && -m === r.translate || !u && m === r.translate) return r.updateActiveIndex(l), d.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), d.effect !== "slide" && r.setTranslate(m), b !== "reset" && (r.transitionStart(t, b), r.transitionEnd(t, b)), !1;
    if (d.cssMode) {
        const S = r.isHorizontal(),
            C = u ? m : -m;
        if (n === 0) {
            const T = r.virtual && r.params.virtual.enabled;
            T && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), g[S ? "scrollLeft" : "scrollTop"] = C, T && requestAnimationFrame(() => {
                r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1
            })
        } else {
            if (!r.support.smoothScroll) return Ge({
                swiper: r,
                targetPosition: C,
                side: S ? "left" : "top"
            }), !0;
            g.scrollTo({
                [S ? "left" : "top"]: C,
                behavior: "smooth"
            })
        }
        return !0
    }
    return r.setTransition(n), r.setTranslate(m), r.updateActiveIndex(l), r.updateSlidesClasses(), r.emit("beforeTransitionStart", n, i), r.transitionStart(t, b), n === 0 ? r.transitionEnd(t, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(C) {
        !r || r.destroyed || C.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(t, b))
    }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0
}

function zn(e = 0, n = this.params.speed, t = !0, i) {
    if (typeof e == "string") {
        const l = parseInt(e, 10);
        if (!isFinite(l)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
        e = l
    }
    const s = this;
    let r = e;
    return s.params.loop && (r += s.loopedSlides), s.slideTo(r, n, t, i)
}

function An(e = this.params.speed, n = !0, t) {
    const i = this,
        {
            animating: s,
            enabled: r,
            params: l
        } = i;
    if (!r) return i;
    let d = l.slidesPerGroup;
    l.slidesPerView === "auto" && l.slidesPerGroup === 1 && l.slidesPerGroupAuto && (d = Math.max(i.slidesPerViewDynamic("current", !0), 1));
    const a = i.activeIndex < l.slidesPerGroupSkip ? 1 : d;
    if (l.loop) {
        if (s && l.loopPreventsSlide) return !1;
        i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft
    }
    return l.rewind && i.isEnd ? i.slideTo(0, e, n, t) : i.slideTo(i.activeIndex + a, e, n, t)
}

function Bn(e = this.params.speed, n = !0, t) {
    const i = this,
        {
            params: s,
            animating: r,
            snapGrid: l,
            slidesGrid: d,
            rtlTranslate: a,
            enabled: o
        } = i;
    if (!o) return i;
    if (s.loop) {
        if (r && s.loopPreventsSlide) return !1;
        i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft
    }
    const c = a ? i.translate : -i.translate;

    function f(h) {
        return h < 0 ? -Math.floor(Math.abs(h)) : Math.floor(h)
    }
    const u = f(c),
        g = l.map(h => f(h));
    let v = l[g.indexOf(u) - 1];
    if (typeof v > "u" && s.cssMode) {
        let h;
        l.forEach((m, b) => {
            u >= m && (h = b)
        }), typeof h < "u" && (v = l[h > 0 ? h - 1 : h])
    }
    let p = 0;
    if (typeof v < "u" && (p = d.indexOf(v), p < 0 && (p = i.activeIndex - 1), s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (p = p - i.slidesPerViewDynamic("previous", !0) + 1, p = Math.max(p, 0))), s.rewind && i.isBeginning) {
        const h = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1;
        return i.slideTo(h, e, n, t)
    }
    return i.slideTo(p, e, n, t)
}

function Rn(e = this.params.speed, n = !0, t) {
    const i = this;
    return i.slideTo(i.activeIndex, e, n, t)
}

function Gn(e = this.params.speed, n = !0, t, i = .5) {
    const s = this;
    let r = s.activeIndex;
    const l = Math.min(s.params.slidesPerGroupSkip, r),
        d = l + Math.floor((r - l) / s.params.slidesPerGroup),
        a = s.rtlTranslate ? s.translate : -s.translate;
    if (a >= s.snapGrid[d]) {
        const o = s.snapGrid[d],
            c = s.snapGrid[d + 1];
        a - o > (c - o) * i && (r += s.params.slidesPerGroup)
    } else {
        const o = s.snapGrid[d - 1],
            c = s.snapGrid[d];
        a - o <= (c - o) * i && (r -= s.params.slidesPerGroup)
    }
    return r = Math.max(r, 0), r = Math.min(r, s.slidesGrid.length - 1), s.slideTo(r, e, n, t)
}

function Hn() {
    const e = this,
        {
            params: n,
            $wrapperEl: t
        } = e,
        i = n.slidesPerView === "auto" ? e.slidesPerViewDynamic() : n.slidesPerView;
    let s = e.clickedIndex,
        r;
    if (n.loop) {
        if (e.animating) return;
        r = parseInt(x(e.clickedSlide).attr("data-swiper-slide-index"), 10), n.centeredSlides ? s < e.loopedSlides - i / 2 || s > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), s = t.children(`.${n.slideClass}[data-swiper-slide-index="${r}"]:not(.${n.slideDuplicateClass})`).eq(0).index(), Se(() => {
            e.slideTo(s)
        })) : e.slideTo(s) : s > e.slides.length - i ? (e.loopFix(), s = t.children(`.${n.slideClass}[data-swiper-slide-index="${r}"]:not(.${n.slideDuplicateClass})`).eq(0).index(), Se(() => {
            e.slideTo(s)
        })) : e.slideTo(s)
    } else e.slideTo(s)
}
const Vn = {
    slideTo: Dn,
    slideToLoop: zn,
    slideNext: An,
    slidePrev: Bn,
    slideReset: Rn,
    slideToClosest: Gn,
    slideToClickedSlide: Hn
};

function Fn() {
    const e = this,
        n = z(),
        {
            params: t,
            $wrapperEl: i
        } = e,
        s = i.children().length > 0 ? x(i.children()[0].parentNode) : i;
    s.children(`.${t.slideClass}.${t.slideDuplicateClass}`).remove();
    let r = s.children(`.${t.slideClass}`);
    if (t.loopFillGroupWithBlank) {
        const a = t.slidesPerGroup - r.length % t.slidesPerGroup;
        if (a !== t.slidesPerGroup) {
            for (let o = 0; o < a; o += 1) {
                const c = x(n.createElement("div")).addClass(`${t.slideClass} ${t.slideBlankClass}`);
                s.append(c)
            }
            r = s.children(`.${t.slideClass}`)
        }
    }
    t.slidesPerView === "auto" && !t.loopedSlides && (t.loopedSlides = r.length), e.loopedSlides = Math.ceil(parseFloat(t.loopedSlides || t.slidesPerView, 10)), e.loopedSlides += t.loopAdditionalSlides, e.loopedSlides > r.length && e.params.loopedSlidesLimit && (e.loopedSlides = r.length);
    const l = [],
        d = [];
    r.each((a, o) => {
        x(a).attr("data-swiper-slide-index", o)
    });
    for (let a = 0; a < e.loopedSlides; a += 1) {
        const o = a - Math.floor(a / r.length) * r.length;
        d.push(r.eq(o)[0]), l.unshift(r.eq(r.length - o - 1)[0])
    }
    for (let a = 0; a < d.length; a += 1) s.append(x(d[a].cloneNode(!0)).addClass(t.slideDuplicateClass));
    for (let a = l.length - 1; a >= 0; a -= 1) s.prepend(x(l[a].cloneNode(!0)).addClass(t.slideDuplicateClass))
}

function jn() {
    const e = this;
    e.emit("beforeLoopFix");
    const {
        activeIndex: n,
        slides: t,
        loopedSlides: i,
        allowSlidePrev: s,
        allowSlideNext: r,
        snapGrid: l,
        rtlTranslate: d
    } = e;
    let a;
    e.allowSlidePrev = !0, e.allowSlideNext = !0;
    const c = -l[n] - e.getTranslate();
    n < i ? (a = t.length - i * 3 + n, a += i, e.slideTo(a, 0, !1, !0) && c !== 0 && e.setTranslate((d ? -e.translate : e.translate) - c)) : n >= t.length - i && (a = -t.length + n + i, a += i, e.slideTo(a, 0, !1, !0) && c !== 0 && e.setTranslate((d ? -e.translate : e.translate) - c)), e.allowSlidePrev = s, e.allowSlideNext = r, e.emit("loopFix")
}

function Wn() {
    const e = this,
        {
            $wrapperEl: n,
            params: t,
            slides: i
        } = e;
    n.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index")
}
const Yn = {
    loopCreate: Fn,
    loopFix: jn,
    loopDestroy: Wn
};

function qn(e) {
    const n = this;
    if (n.support.touch || !n.params.simulateTouch || n.params.watchOverflow && n.isLocked || n.params.cssMode) return;
    const t = n.params.touchEventsTarget === "container" ? n.el : n.wrapperEl;
    t.style.cursor = "move", t.style.cursor = e ? "grabbing" : "grab"
}

function Xn() {
    const e = this;
    e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e[e.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "")
}
const Un = {
    setGrabCursor: qn,
    unsetGrabCursor: Xn
};

function Kn(e, n = this) {
    function t(i) {
        if (!i || i === z() || i === N()) return null;
        i.assignedSlot && (i = i.assignedSlot);
        const s = i.closest(e);
        return !s && !i.getRootNode ? null : s || t(i.getRootNode().host)
    }
    return t(n)
}

function Qn(e) {
    const n = this,
        t = z(),
        i = N(),
        s = n.touchEventsData,
        {
            params: r,
            touches: l,
            enabled: d
        } = n;
    if (!d || n.animating && r.preventInteractionOnTransition) return;
    !n.animating && r.cssMode && r.loop && n.loopFix();
    let a = e;
    a.originalEvent && (a = a.originalEvent);
    let o = x(a.target);
    if (r.touchEventsTarget === "wrapper" && !o.closest(n.wrapperEl).length || (s.isTouchEvent = a.type === "touchstart", !s.isTouchEvent && "which" in a && a.which === 3) || !s.isTouchEvent && "button" in a && a.button > 0 || s.isTouched && s.isMoved) return;
    const c = !!r.noSwipingClass && r.noSwipingClass !== "",
        f = e.composedPath ? e.composedPath() : e.path;
    c && a.target && a.target.shadowRoot && f && (o = x(f[0]));
    const u = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`,
        g = !!(a.target && a.target.shadowRoot);
    if (r.noSwiping && (g ? Kn(u, o[0]) : o.closest(u)[0])) {
        n.allowClick = !0;
        return
    }
    if (r.swipeHandler && !o.closest(r.swipeHandler)[0]) return;
    l.currentX = a.type === "touchstart" ? a.targetTouches[0].pageX : a.pageX, l.currentY = a.type === "touchstart" ? a.targetTouches[0].pageY : a.pageY;
    const v = l.currentX,
        p = l.currentY,
        h = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection,
        m = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold;
    if (h && (v <= m || v >= i.innerWidth - m))
        if (h === "prevent") e.preventDefault();
        else return;
    if (Object.assign(s, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), l.startX = v, l.startY = p, s.touchStartTime = q(), n.allowClick = !0, n.updateSize(), n.swipeDirection = void 0, r.threshold > 0 && (s.allowThresholdMove = !1), a.type !== "touchstart") {
        let b = !0;
        o.is(s.focusableElements) && (b = !1, o[0].nodeName === "SELECT" && (s.isTouched = !1)), t.activeElement && x(t.activeElement).is(s.focusableElements) && t.activeElement !== o[0] && t.activeElement.blur();
        const S = b && n.allowTouchMove && r.touchStartPreventDefault;
        (r.touchStartForcePreventDefault || S) && !o[0].isContentEditable && a.preventDefault()
    }
    n.params.freeMode && n.params.freeMode.enabled && n.freeMode && n.animating && !r.cssMode && n.freeMode.onTouchStart(), n.emit("touchStart", a)
}

function Jn(e) {
    const n = z(),
        t = this,
        i = t.touchEventsData,
        {
            params: s,
            touches: r,
            rtlTranslate: l,
            enabled: d
        } = t;
    if (!d) return;
    let a = e;
    if (a.originalEvent && (a = a.originalEvent), !i.isTouched) {
        i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", a);
        return
    }
    if (i.isTouchEvent && a.type !== "touchmove") return;
    const o = a.type === "touchmove" && a.targetTouches && (a.targetTouches[0] || a.changedTouches[0]),
        c = a.type === "touchmove" ? o.pageX : a.pageX,
        f = a.type === "touchmove" ? o.pageY : a.pageY;
    if (a.preventedByNestedSwiper) {
        r.startX = c, r.startY = f;
        return
    }
    if (!t.allowTouchMove) {
        x(a.target).is(i.focusableElements) || (t.allowClick = !1), i.isTouched && (Object.assign(r, {
            startX: c,
            startY: f,
            currentX: c,
            currentY: f
        }), i.touchStartTime = q());
        return
    }
    if (i.isTouchEvent && s.touchReleaseOnEdges && !s.loop) {
        if (t.isVertical()) {
            if (f < r.startY && t.translate <= t.maxTranslate() || f > r.startY && t.translate >= t.minTranslate()) {
                i.isTouched = !1, i.isMoved = !1;
                return
            }
        } else if (c < r.startX && t.translate <= t.maxTranslate() || c > r.startX && t.translate >= t.minTranslate()) return
    }
    if (i.isTouchEvent && n.activeElement && a.target === n.activeElement && x(a.target).is(i.focusableElements)) {
        i.isMoved = !0, t.allowClick = !1;
        return
    }
    if (i.allowTouchCallbacks && t.emit("touchMove", a), a.targetTouches && a.targetTouches.length > 1) return;
    r.currentX = c, r.currentY = f;
    const u = r.currentX - r.startX,
        g = r.currentY - r.startY;
    if (t.params.threshold && Math.sqrt(u ** 2 + g ** 2) < t.params.threshold) return;
    if (typeof i.isScrolling > "u") {
        let m;
        t.isHorizontal() && r.currentY === r.startY || t.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : u * u + g * g >= 25 && (m = Math.atan2(Math.abs(g), Math.abs(u)) * 180 / Math.PI, i.isScrolling = t.isHorizontal() ? m > s.touchAngle : 90 - m > s.touchAngle)
    }
    if (i.isScrolling && t.emit("touchMoveOpposite", a), typeof i.startMoving > "u" && (r.currentX !== r.startX || r.currentY !== r.startY) && (i.startMoving = !0), i.isScrolling) {
        i.isTouched = !1;
        return
    }
    if (!i.startMoving) return;
    t.allowClick = !1, !s.cssMode && a.cancelable && a.preventDefault(), s.touchMoveStopPropagation && !s.nested && a.stopPropagation(), i.isMoved || (s.loop && !s.cssMode && t.loopFix(), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating && t.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, s.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", a)), t.emit("sliderMove", a), i.isMoved = !0;
    let v = t.isHorizontal() ? u : g;
    r.diff = v, v *= s.touchRatio, l && (v = -v), t.swipeDirection = v > 0 ? "prev" : "next", i.currentTranslate = v + i.startTranslate;
    let p = !0,
        h = s.resistanceRatio;
    if (s.touchReleaseOnEdges && (h = 0), v > 0 && i.currentTranslate > t.minTranslate() ? (p = !1, s.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + v) ** h)) : v < 0 && i.currentTranslate < t.maxTranslate() && (p = !1, s.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - v) ** h)), p && (a.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (i.currentTranslate = i.startTranslate), s.threshold > 0)
        if (Math.abs(v) > s.threshold || i.allowThresholdMove) {
            if (!i.allowThresholdMove) {
                i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, r.diff = t.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY;
                return
            }
        } else {
            i.currentTranslate = i.startTranslate;
            return
        }!s.followFinger || s.cssMode || ((s.freeMode && s.freeMode.enabled && t.freeMode || s.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), t.params.freeMode && s.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate))
}

function Zn(e) {
    const n = this,
        t = n.touchEventsData,
        {
            params: i,
            touches: s,
            rtlTranslate: r,
            slidesGrid: l,
            enabled: d
        } = n;
    if (!d) return;
    let a = e;
    if (a.originalEvent && (a = a.originalEvent), t.allowTouchCallbacks && n.emit("touchEnd", a), t.allowTouchCallbacks = !1, !t.isTouched) {
        t.isMoved && i.grabCursor && n.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1;
        return
    }
    i.grabCursor && t.isMoved && t.isTouched && (n.allowSlideNext === !0 || n.allowSlidePrev === !0) && n.setGrabCursor(!1);
    const o = q(),
        c = o - t.touchStartTime;
    if (n.allowClick) {
        const b = a.path || a.composedPath && a.composedPath();
        n.updateClickedSlide(b && b[0] || a.target), n.emit("tap click", a), c < 300 && o - t.lastClickTime < 300 && n.emit("doubleTap doubleClick", a)
    }
    if (t.lastClickTime = q(), Se(() => {
            n.destroyed || (n.allowClick = !0)
        }), !t.isTouched || !t.isMoved || !n.swipeDirection || s.diff === 0 || t.currentTranslate === t.startTranslate) {
        t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
        return
    }
    t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
    let f;
    if (i.followFinger ? f = r ? n.translate : -n.translate : f = -t.currentTranslate, i.cssMode) return;
    if (n.params.freeMode && i.freeMode.enabled) {
        n.freeMode.onTouchEnd({
            currentPos: f
        });
        return
    }
    let u = 0,
        g = n.slidesSizesGrid[0];
    for (let b = 0; b < l.length; b += b < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup) {
        const S = b < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
        typeof l[b + S] < "u" ? f >= l[b] && f < l[b + S] && (u = b, g = l[b + S] - l[b]) : f >= l[b] && (u = b, g = l[l.length - 1] - l[l.length - 2])
    }
    let v = null,
        p = null;
    i.rewind && (n.isBeginning ? p = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1 : n.isEnd && (v = 0));
    const h = (f - l[u]) / g,
        m = u < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
    if (c > i.longSwipesMs) {
        if (!i.longSwipes) {
            n.slideTo(n.activeIndex);
            return
        }
        n.swipeDirection === "next" && (h >= i.longSwipesRatio ? n.slideTo(i.rewind && n.isEnd ? v : u + m) : n.slideTo(u)), n.swipeDirection === "prev" && (h > 1 - i.longSwipesRatio ? n.slideTo(u + m) : p !== null && h < 0 && Math.abs(h) > i.longSwipesRatio ? n.slideTo(p) : n.slideTo(u))
    } else {
        if (!i.shortSwipes) {
            n.slideTo(n.activeIndex);
            return
        }
        n.navigation && (a.target === n.navigation.nextEl || a.target === n.navigation.prevEl) ? a.target === n.navigation.nextEl ? n.slideTo(u + m) : n.slideTo(u) : (n.swipeDirection === "next" && n.slideTo(v !== null ? v : u + m), n.swipeDirection === "prev" && n.slideTo(p !== null ? p : u))
    }
}

function Oe() {
    const e = this,
        {
            params: n,
            el: t
        } = e;
    if (t && t.offsetWidth === 0) return;
    n.breakpoints && e.setBreakpoint();
    const {
        allowSlideNext: i,
        allowSlidePrev: s,
        snapGrid: r
    } = e;
    e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), (n.slidesPerView === "auto" || n.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = s, e.allowSlideNext = i, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
}

function ei(e) {
    const n = this;
    n.enabled && (n.allowClick || (n.params.preventClicks && e.preventDefault(), n.params.preventClicksPropagation && n.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
}

function ti() {
    const e = this,
        {
            wrapperEl: n,
            rtlTranslate: t,
            enabled: i
        } = e;
    if (!i) return;
    e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -n.scrollLeft : e.translate = -n.scrollTop, e.translate === 0 && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
    let s;
    const r = e.maxTranslate() - e.minTranslate();
    r === 0 ? s = 0 : s = (e.translate - e.minTranslate()) / r, s !== e.progress && e.updateProgress(t ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
}
let Pe = !1;

function ni() {}
const Fe = (e, n) => {
    const t = z(),
        {
            params: i,
            touchEvents: s,
            el: r,
            wrapperEl: l,
            device: d,
            support: a
        } = e,
        o = !!i.nested,
        c = n === "on" ? "addEventListener" : "removeEventListener",
        f = n;
    if (!a.touch) r[c](s.start, e.onTouchStart, !1), t[c](s.move, e.onTouchMove, o), t[c](s.end, e.onTouchEnd, !1);
    else {
        const u = s.start === "touchstart" && a.passiveListener && i.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1;
        r[c](s.start, e.onTouchStart, u), r[c](s.move, e.onTouchMove, a.passiveListener ? {
            passive: !1,
            capture: o
        } : o), r[c](s.end, e.onTouchEnd, u), s.cancel && r[c](s.cancel, e.onTouchEnd, u)
    }(i.preventClicks || i.preventClicksPropagation) && r[c]("click", e.onClick, !0), i.cssMode && l[c]("scroll", e.onScroll), i.updateOnWindowResize ? e[f](d.ios || d.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Oe, !0) : e[f]("observerUpdate", Oe, !0)
};

function ii() {
    const e = this,
        n = z(),
        {
            params: t,
            support: i
        } = e;
    e.onTouchStart = Qn.bind(e), e.onTouchMove = Jn.bind(e), e.onTouchEnd = Zn.bind(e), t.cssMode && (e.onScroll = ti.bind(e)), e.onClick = ei.bind(e), i.touch && !Pe && (n.addEventListener("touchstart", ni), Pe = !0), Fe(e, "on")
}

function si() {
    Fe(this, "off")
}
const ri = {
        attachEvents: ii,
        detachEvents: si
    },
    ke = (e, n) => e.grid && n.grid && n.grid.rows > 1;

function ai() {
    const e = this,
        {
            activeIndex: n,
            initialized: t,
            loopedSlides: i = 0,
            params: s,
            $el: r
        } = e,
        l = s.breakpoints;
    if (!l || l && Object.keys(l).length === 0) return;
    const d = e.getBreakpoint(l, e.params.breakpointsBase, e.el);
    if (!d || e.currentBreakpoint === d) return;
    const o = (d in l ? l[d] : void 0) || e.originalParams,
        c = ke(e, s),
        f = ke(e, o),
        u = s.enabled;
    c && !f ? (r.removeClass(`${s.containerModifierClass}grid ${s.containerModifierClass}grid-column`), e.emitContainerClasses()) : !c && f && (r.addClass(`${s.containerModifierClass}grid`), (o.grid.fill && o.grid.fill === "column" || !o.grid.fill && s.grid.fill === "column") && r.addClass(`${s.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(h => {
        const m = s[h] && s[h].enabled,
            b = o[h] && o[h].enabled;
        m && !b && e[h].disable(), !m && b && e[h].enable()
    });
    const g = o.direction && o.direction !== s.direction,
        v = s.loop && (o.slidesPerView !== s.slidesPerView || g);
    g && t && e.changeDirection(), A(e.params, o);
    const p = e.params.enabled;
    Object.assign(e, {
        allowTouchMove: e.params.allowTouchMove,
        allowSlideNext: e.params.allowSlideNext,
        allowSlidePrev: e.params.allowSlidePrev
    }), u && !p ? e.disable() : !u && p && e.enable(), e.currentBreakpoint = d, e.emit("_beforeBreakpoint", o), v && t && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(n - i + e.loopedSlides, 0, !1)), e.emit("breakpoint", o)
}

function li(e, n = "window", t) {
    if (!e || n === "container" && !t) return;
    let i = !1;
    const s = N(),
        r = n === "window" ? s.innerHeight : t.clientHeight,
        l = Object.keys(e).map(d => {
            if (typeof d == "string" && d.indexOf("@") === 0) {
                const a = parseFloat(d.substr(1));
                return {
                    value: r * a,
                    point: d
                }
            }
            return {
                value: d,
                point: d
            }
        });
    l.sort((d, a) => parseInt(d.value, 10) - parseInt(a.value, 10));
    for (let d = 0; d < l.length; d += 1) {
        const {
            point: a,
            value: o
        } = l[d];
        n === "window" ? s.matchMedia(`(min-width: ${o}px)`).matches && (i = a) : o <= t.clientWidth && (i = a)
    }
    return i || "max"
}
const oi = {
    setBreakpoint: ai,
    getBreakpoint: li
};

function di(e, n) {
    const t = [];
    return e.forEach(i => {
        typeof i == "object" ? Object.keys(i).forEach(s => {
            i[s] && t.push(n + s)
        }) : typeof i == "string" && t.push(n + i)
    }), t
}

function ci() {
    const e = this,
        {
            classNames: n,
            params: t,
            rtl: i,
            $el: s,
            device: r,
            support: l
        } = e,
        d = di(["initialized", t.direction, {
            "pointer-events": !l.touch
        }, {
            "free-mode": e.params.freeMode && t.freeMode.enabled
        }, {
            autoheight: t.autoHeight
        }, {
            rtl: i
        }, {
            grid: t.grid && t.grid.rows > 1
        }, {
            "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column"
        }, {
            android: r.android
        }, {
            ios: r.ios
        }, {
            "css-mode": t.cssMode
        }, {
            centered: t.cssMode && t.centeredSlides
        }, {
            "watch-progress": t.watchSlidesProgress
        }], t.containerModifierClass);
    n.push(...d), s.addClass([...n].join(" ")), e.emitContainerClasses()
}

function ui() {
    const e = this,
        {
            $el: n,
            classNames: t
        } = e;
    n.removeClass(t.join(" ")), e.emitContainerClasses()
}
const fi = {
    addClasses: ci,
    removeClasses: ui
};

function pi(e, n, t, i, s, r) {
    const l = N();
    let d;

    function a() {
        r && r()
    }!x(e).parent("picture")[0] && (!e.complete || !s) && n ? (d = new l.Image, d.onload = a, d.onerror = a, i && (d.sizes = i), t && (d.srcset = t), n && (d.src = n)) : a()
}

function hi() {
    const e = this;
    e.imagesToLoad = e.$el.find("img");

    function n() {
        typeof e > "u" || e === null || !e || e.destroyed || (e.imagesLoaded !== void 0 && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
    }
    for (let t = 0; t < e.imagesToLoad.length; t += 1) {
        const i = e.imagesToLoad[t];
        e.loadImage(i, i.currentSrc || i.getAttribute("src"), i.srcset || i.getAttribute("srcset"), i.sizes || i.getAttribute("sizes"), !0, n)
    }
}
const mi = {
    loadImage: pi,
    preloadImages: hi
};

function gi() {
    const e = this,
        {
            isLocked: n,
            params: t
        } = e,
        {
            slidesOffsetBefore: i
        } = t;
    if (i) {
        const s = e.slides.length - 1,
            r = e.slidesGrid[s] + e.slidesSizesGrid[s] + i * 2;
        e.isLocked = e.size > r
    } else e.isLocked = e.snapGrid.length === 1;
    t.allowSlideNext === !0 && (e.allowSlideNext = !e.isLocked), t.allowSlidePrev === !0 && (e.allowSlidePrev = !e.isLocked), n && n !== e.isLocked && (e.isEnd = !1), n !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
}
const vi = {
        checkOverflow: gi
    },
    Le = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopedSlidesLimit: !0,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

function bi(e, n) {
    return function(i = {}) {
        const s = Object.keys(i)[0],
            r = i[s];
        if (typeof r != "object" || r === null) {
            A(n, i);
            return
        }
        if (["navigation", "pagination", "scrollbar"].indexOf(s) >= 0 && e[s] === !0 && (e[s] = {
                auto: !0
            }), !(s in e && "enabled" in r)) {
            A(n, i);
            return
        }
        e[s] === !0 && (e[s] = {
            enabled: !0
        }), typeof e[s] == "object" && !("enabled" in e[s]) && (e[s].enabled = !0), e[s] || (e[s] = {
            enabled: !1
        }), A(n, i)
    }
}
const ge = {
        eventsEmitter: hn,
        update: wn,
        translate: Pn,
        transition: In,
        slide: Vn,
        loop: Yn,
        grabCursor: Un,
        events: ri,
        breakpoints: oi,
        checkOverflow: vi,
        classes: fi,
        images: mi
    },
    ve = {};
let ee = class H {
    constructor(...n) {
        let t, i;
        if (n.length === 1 && n[0].constructor && Object.prototype.toString.call(n[0]).slice(8, -1) === "Object" ? i = n[0] : [t, i] = n, i || (i = {}), i = A({}, i), t && !i.el && (i.el = t), i.el && x(i.el).length > 1) {
            const d = [];
            return x(i.el).each(a => {
                const o = A({}, i, {
                    el: a
                });
                d.push(new H(o))
            }), d
        }
        const s = this;
        s.__swiper__ = !0, s.support = He(), s.device = dn({
            userAgent: i.userAgent
        }), s.browser = un(), s.eventsListeners = {}, s.eventsAnyListeners = [], s.modules = [...s.__modules__], i.modules && Array.isArray(i.modules) && s.modules.push(...i.modules);
        const r = {};
        s.modules.forEach(d => {
            d({
                swiper: s,
                extendParams: bi(i, r),
                on: s.on.bind(s),
                once: s.once.bind(s),
                off: s.off.bind(s),
                emit: s.emit.bind(s)
            })
        });
        const l = A({}, Le, r);
        return s.params = A({}, l, ve, i), s.originalParams = A({}, s.params), s.passedParams = A({}, i), s.params && s.params.on && Object.keys(s.params.on).forEach(d => {
            s.on(d, s.params.on[d])
        }), s.params && s.params.onAny && s.onAny(s.params.onAny), s.$ = x, Object.assign(s, {
            enabled: s.params.enabled,
            el: t,
            classNames: [],
            slides: x(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return s.params.direction === "horizontal"
            },
            isVertical() {
                return s.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            allowSlideNext: s.params.allowSlideNext,
            allowSlidePrev: s.params.allowSlidePrev,
            touchEvents: function() {
                const a = ["touchstart", "touchmove", "touchend", "touchcancel"],
                    o = ["pointerdown", "pointermove", "pointerup"];
                return s.touchEventsTouch = {
                    start: a[0],
                    move: a[1],
                    end: a[2],
                    cancel: a[3]
                }, s.touchEventsDesktop = {
                    start: o[0],
                    move: o[1],
                    end: o[2]
                }, s.support.touch || !s.params.simulateTouch ? s.touchEventsTouch : s.touchEventsDesktop
            }(),
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: s.params.focusableElements,
                lastClickTime: q(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0
            },
            allowClick: !0,
            allowTouchMove: s.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }), s.emit("_swiper"), s.params.init && s.init(), s
    }
    enable() {
        const n = this;
        n.enabled || (n.enabled = !0, n.params.grabCursor && n.setGrabCursor(), n.emit("enable"))
    }
    disable() {
        const n = this;
        n.enabled && (n.enabled = !1, n.params.grabCursor && n.unsetGrabCursor(), n.emit("disable"))
    }
    setProgress(n, t) {
        const i = this;
        n = Math.min(Math.max(n, 0), 1);
        const s = i.minTranslate(),
            l = (i.maxTranslate() - s) * n + s;
        i.translateTo(l, typeof t > "u" ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses()
    }
    emitContainerClasses() {
        const n = this;
        if (!n.params._emitClasses || !n.el) return;
        const t = n.el.className.split(" ").filter(i => i.indexOf("swiper") === 0 || i.indexOf(n.params.containerModifierClass) === 0);
        n.emit("_containerClasses", t.join(" "))
    }
    getSlideClasses(n) {
        const t = this;
        return t.destroyed ? "" : n.className.split(" ").filter(i => i.indexOf("swiper-slide") === 0 || i.indexOf(t.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const n = this;
        if (!n.params._emitClasses || !n.el) return;
        const t = [];
        n.slides.each(i => {
            const s = n.getSlideClasses(i);
            t.push({
                slideEl: i,
                classNames: s
            }), n.emit("_slideClass", i, s)
        }), n.emit("_slideClasses", t)
    }
    slidesPerViewDynamic(n = "current", t = !1) {
        const i = this,
            {
                params: s,
                slides: r,
                slidesGrid: l,
                slidesSizesGrid: d,
                size: a,
                activeIndex: o
            } = i;
        let c = 1;
        if (s.centeredSlides) {
            let f = r[o].swiperSlideSize,
                u;
            for (let g = o + 1; g < r.length; g += 1) r[g] && !u && (f += r[g].swiperSlideSize, c += 1, f > a && (u = !0));
            for (let g = o - 1; g >= 0; g -= 1) r[g] && !u && (f += r[g].swiperSlideSize, c += 1, f > a && (u = !0))
        } else if (n === "current")
            for (let f = o + 1; f < r.length; f += 1)(t ? l[f] + d[f] - l[o] < a : l[f] - l[o] < a) && (c += 1);
        else
            for (let f = o - 1; f >= 0; f -= 1) l[o] - l[f] < a && (c += 1);
        return c
    }
    update() {
        const n = this;
        if (!n || n.destroyed) return;
        const {
            snapGrid: t,
            params: i
        } = n;
        i.breakpoints && n.setBreakpoint(), n.updateSize(), n.updateSlides(), n.updateProgress(), n.updateSlidesClasses();

        function s() {
            const l = n.rtlTranslate ? n.translate * -1 : n.translate,
                d = Math.min(Math.max(l, n.maxTranslate()), n.minTranslate());
            n.setTranslate(d), n.updateActiveIndex(), n.updateSlidesClasses()
        }
        let r;
        n.params.freeMode && n.params.freeMode.enabled ? (s(), n.params.autoHeight && n.updateAutoHeight()) : ((n.params.slidesPerView === "auto" || n.params.slidesPerView > 1) && n.isEnd && !n.params.centeredSlides ? r = n.slideTo(n.slides.length - 1, 0, !1, !0) : r = n.slideTo(n.activeIndex, 0, !1, !0), r || s()), i.watchOverflow && t !== n.snapGrid && n.checkOverflow(), n.emit("update")
    }
    changeDirection(n, t = !0) {
        const i = this,
            s = i.params.direction;
        return n || (n = s === "horizontal" ? "vertical" : "horizontal"), n === s || n !== "horizontal" && n !== "vertical" || (i.$el.removeClass(`${i.params.containerModifierClass}${s}`).addClass(`${i.params.containerModifierClass}${n}`), i.emitContainerClasses(), i.params.direction = n, i.slides.each(r => {
            n === "vertical" ? r.style.width = "" : r.style.height = ""
        }), i.emit("changeDirection"), t && i.update()), i
    }
    changeLanguageDirection(n) {
        const t = this;
        t.rtl && n === "rtl" || !t.rtl && n === "ltr" || (t.rtl = n === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
    }
    mount(n) {
        const t = this;
        if (t.mounted) return !0;
        const i = x(n || t.params.el);
        if (n = i[0], !n) return !1;
        n.swiper = t;
        const s = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
        let l = (() => {
            if (n && n.shadowRoot && n.shadowRoot.querySelector) {
                const d = x(n.shadowRoot.querySelector(s()));
                return d.children = a => i.children(a), d
            }
            return i.children ? i.children(s()) : x(i).children(s())
        })();
        if (l.length === 0 && t.params.createElements) {
            const a = z().createElement("div");
            l = x(a), a.className = t.params.wrapperClass, i.append(a), i.children(`.${t.params.slideClass}`).each(o => {
                l.append(o)
            })
        }
        return Object.assign(t, {
            $el: i,
            el: n,
            $wrapperEl: l,
            wrapperEl: l[0],
            mounted: !0,
            rtl: n.dir.toLowerCase() === "rtl" || i.css("direction") === "rtl",
            rtlTranslate: t.params.direction === "horizontal" && (n.dir.toLowerCase() === "rtl" || i.css("direction") === "rtl"),
            wrongRTL: l.css("display") === "-webkit-box"
        }), !0
    }
    init(n) {
        const t = this;
        return t.initialized || t.mount(n) === !1 || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t
    }
    destroy(n = !0, t = !0) {
        const i = this,
            {
                params: s,
                $el: r,
                $wrapperEl: l,
                slides: d
            } = i;
        return typeof i.params > "u" || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), r.removeAttr("style"), l.removeAttr("style"), d && d.length && d.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(a => {
            i.off(a)
        }), n !== !1 && (i.$el[0].swiper = null, nn(i)), i.destroyed = !0), null
    }
    static extendDefaults(n) {
        A(ve, n)
    }
    static get extendedDefaults() {
        return ve
    }
    static get defaults() {
        return Le
    }
    static installModule(n) {
        H.prototype.__modules__ || (H.prototype.__modules__ = []);
        const t = H.prototype.__modules__;
        typeof n == "function" && t.indexOf(n) < 0 && t.push(n)
    }
    static use(n) {
        return Array.isArray(n) ? (n.forEach(t => H.installModule(t)), H) : (H.installModule(n), H)
    }
};
Object.keys(ge).forEach(e => {
    Object.keys(ge[e]).forEach(n => {
        ee.prototype[n] = ge[e][n]
    })
});
ee.use([fn, pn]);

function je(e, n, t, i) {
    const s = z();
    return e.params.createElements && Object.keys(i).forEach(r => {
        if (!t[r] && t.auto === !0) {
            let l = e.$el.children(`.${i[r]}`)[0];
            l || (l = s.createElement("div"), l.className = i[r], e.$el.append(l)), t[r] = l, n[r] = l
        }
    }), t
}

function Si({
    swiper: e,
    extendParams: n,
    on: t,
    emit: i
}) {
    n({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    }), e.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null
    };

    function s(g) {
        let v;
        return g && (v = x(g), e.params.uniqueNavElements && typeof g == "string" && v.length > 1 && e.$el.find(g).length === 1 && (v = e.$el.find(g))), v
    }

    function r(g, v) {
        const p = e.params.navigation;
        g && g.length > 0 && (g[v ? "addClass" : "removeClass"](p.disabledClass), g[0] && g[0].tagName === "BUTTON" && (g[0].disabled = v), e.params.watchOverflow && e.enabled && g[e.isLocked ? "addClass" : "removeClass"](p.lockClass))
    }

    function l() {
        if (e.params.loop) return;
        const {
            $nextEl: g,
            $prevEl: v
        } = e.navigation;
        r(v, e.isBeginning && !e.params.rewind), r(g, e.isEnd && !e.params.rewind)
    }

    function d(g) {
        g.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), i("navigationPrev"))
    }

    function a(g) {
        g.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), i("navigationNext"))
    }

    function o() {
        const g = e.params.navigation;
        if (e.params.navigation = je(e, e.originalParams.navigation, e.params.navigation, {
                nextEl: "swiper-button-next",
                prevEl: "swiper-button-prev"
            }), !(g.nextEl || g.prevEl)) return;
        const v = s(g.nextEl),
            p = s(g.prevEl);
        v && v.length > 0 && v.on("click", a), p && p.length > 0 && p.on("click", d), Object.assign(e.navigation, {
            $nextEl: v,
            nextEl: v && v[0],
            $prevEl: p,
            prevEl: p && p[0]
        }), e.enabled || (v && v.addClass(g.lockClass), p && p.addClass(g.lockClass))
    }

    function c() {
        const {
            $nextEl: g,
            $prevEl: v
        } = e.navigation;
        g && g.length && (g.off("click", a), g.removeClass(e.params.navigation.disabledClass)), v && v.length && (v.off("click", d), v.removeClass(e.params.navigation.disabledClass))
    }
    t("init", () => {
        e.params.navigation.enabled === !1 ? u() : (o(), l())
    }), t("toEdge fromEdge lock unlock", () => {
        l()
    }), t("destroy", () => {
        c()
    }), t("enable disable", () => {
        const {
            $nextEl: g,
            $prevEl: v
        } = e.navigation;
        g && g[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), v && v[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass)
    }), t("click", (g, v) => {
        const {
            $nextEl: p,
            $prevEl: h
        } = e.navigation, m = v.target;
        if (e.params.navigation.hideOnClick && !x(m).is(h) && !x(m).is(p)) {
            if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === m || e.pagination.el.contains(m))) return;
            let b;
            p ? b = p.hasClass(e.params.navigation.hiddenClass) : h && (b = h.hasClass(e.params.navigation.hiddenClass)), i(b === !0 ? "navigationShow" : "navigationHide"), p && p.toggleClass(e.params.navigation.hiddenClass), h && h.toggleClass(e.params.navigation.hiddenClass)
        }
    });
    const f = () => {
            e.$el.removeClass(e.params.navigation.navigationDisabledClass), o(), l()
        },
        u = () => {
            e.$el.addClass(e.params.navigation.navigationDisabledClass), c()
        };
    Object.assign(e.navigation, {
        enable: f,
        disable: u,
        update: l,
        init: o,
        destroy: c
    })
}

function J(e = "") {
    return `.${e.trim().replace(/([\.:!\/])/g,"\\$1").replace(/ /g,".")}`
}

function xi({
    swiper: e,
    extendParams: n,
    on: t,
    emit: i
}) {
    const s = "swiper-pagination";
    n({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: p => p,
            formatFractionTotal: p => p,
            bulletClass: `${s}-bullet`,
            bulletActiveClass: `${s}-bullet-active`,
            modifierClass: `${s}-`,
            currentClass: `${s}-current`,
            totalClass: `${s}-total`,
            hiddenClass: `${s}-hidden`,
            progressbarFillClass: `${s}-progressbar-fill`,
            progressbarOppositeClass: `${s}-progressbar-opposite`,
            clickableClass: `${s}-clickable`,
            lockClass: `${s}-lock`,
            horizontalClass: `${s}-horizontal`,
            verticalClass: `${s}-vertical`,
            paginationDisabledClass: `${s}-disabled`
        }
    }), e.pagination = {
        el: null,
        $el: null,
        bullets: []
    };
    let r, l = 0;

    function d() {
        return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || e.pagination.$el.length === 0
    }

    function a(p, h) {
        const {
            bulletActiveClass: m
        } = e.params.pagination;
        p[h]().addClass(`${m}-${h}`)[h]().addClass(`${m}-${h}-${h}`)
    }

    function o() {
        const p = e.rtl,
            h = e.params.pagination;
        if (d()) return;
        const m = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
            b = e.pagination.$el;
        let S;
        const C = e.params.loop ? Math.ceil((m - e.loopedSlides * 2) / e.params.slidesPerGroup) : e.snapGrid.length;
        if (e.params.loop ? (S = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), S > m - 1 - e.loopedSlides * 2 && (S -= m - e.loopedSlides * 2), S > C - 1 && (S -= C), S < 0 && e.params.paginationType !== "bullets" && (S = C + S)) : typeof e.snapIndex < "u" ? S = e.snapIndex : S = e.activeIndex || 0, h.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
            const T = e.pagination.bullets;
            let M, P, $;
            if (h.dynamicBullets && (r = T.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), b.css(e.isHorizontal() ? "width" : "height", `${r*(h.dynamicMainBullets+4)}px`), h.dynamicMainBullets > 1 && e.previousIndex !== void 0 && (l += S - (e.previousIndex - e.loopedSlides || 0), l > h.dynamicMainBullets - 1 ? l = h.dynamicMainBullets - 1 : l < 0 && (l = 0)), M = Math.max(S - l, 0), P = M + (Math.min(T.length, h.dynamicMainBullets) - 1), $ = (P + M) / 2), T.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(I => `${h.bulletActiveClass}${I}`).join(" ")), b.length > 1) T.each(I => {
                const w = x(I),
                    E = w.index();
                E === S && w.addClass(h.bulletActiveClass), h.dynamicBullets && (E >= M && E <= P && w.addClass(`${h.bulletActiveClass}-main`), E === M && a(w, "prev"), E === P && a(w, "next"))
            });
            else {
                const I = T.eq(S),
                    w = I.index();
                if (I.addClass(h.bulletActiveClass), h.dynamicBullets) {
                    const E = T.eq(M),
                        _ = T.eq(P);
                    for (let k = M; k <= P; k += 1) T.eq(k).addClass(`${h.bulletActiveClass}-main`);
                    if (e.params.loop)
                        if (w >= T.length) {
                            for (let k = h.dynamicMainBullets; k >= 0; k -= 1) T.eq(T.length - k).addClass(`${h.bulletActiveClass}-main`);
                            T.eq(T.length - h.dynamicMainBullets - 1).addClass(`${h.bulletActiveClass}-prev`)
                        } else a(E, "prev"), a(_, "next");
                    else a(E, "prev"), a(_, "next")
                }
            }
            if (h.dynamicBullets) {
                const I = Math.min(T.length, h.dynamicMainBullets + 4),
                    w = (r * I - r) / 2 - $ * r,
                    E = p ? "right" : "left";
                T.css(e.isHorizontal() ? E : "top", `${w}px`)
            }
        }
        if (h.type === "fraction" && (b.find(J(h.currentClass)).text(h.formatFractionCurrent(S + 1)), b.find(J(h.totalClass)).text(h.formatFractionTotal(C))), h.type === "progressbar") {
            let T;
            h.progressbarOpposite ? T = e.isHorizontal() ? "vertical" : "horizontal" : T = e.isHorizontal() ? "horizontal" : "vertical";
            const M = (S + 1) / C;
            let P = 1,
                $ = 1;
            T === "horizontal" ? P = M : $ = M, b.find(J(h.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${P}) scaleY(${$})`).transition(e.params.speed)
        }
        h.type === "custom" && h.renderCustom ? (b.html(h.renderCustom(e, S + 1, C)), i("paginationRender", b[0])) : i("paginationUpdate", b[0]), e.params.watchOverflow && e.enabled && b[e.isLocked ? "addClass" : "removeClass"](h.lockClass)
    }

    function c() {
        const p = e.params.pagination;
        if (d()) return;
        const h = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
            m = e.pagination.$el;
        let b = "";
        if (p.type === "bullets") {
            let S = e.params.loop ? Math.ceil((h - e.loopedSlides * 2) / e.params.slidesPerGroup) : e.snapGrid.length;
            e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && S > h && (S = h);
            for (let C = 0; C < S; C += 1) p.renderBullet ? b += p.renderBullet.call(e, C, p.bulletClass) : b += `<${p.bulletElement} class="${p.bulletClass}"></${p.bulletElement}>`;
            m.html(b), e.pagination.bullets = m.find(J(p.bulletClass))
        }
        p.type === "fraction" && (p.renderFraction ? b = p.renderFraction.call(e, p.currentClass, p.totalClass) : b = `<span class="${p.currentClass}"></span> / <span class="${p.totalClass}"></span>`, m.html(b)), p.type === "progressbar" && (p.renderProgressbar ? b = p.renderProgressbar.call(e, p.progressbarFillClass) : b = `<span class="${p.progressbarFillClass}"></span>`, m.html(b)), p.type !== "custom" && i("paginationRender", e.pagination.$el[0])
    }

    function f() {
        e.params.pagination = je(e, e.originalParams.pagination, e.params.pagination, {
            el: "swiper-pagination"
        });
        const p = e.params.pagination;
        if (!p.el) return;
        let h = x(p.el);
        h.length !== 0 && (e.params.uniqueNavElements && typeof p.el == "string" && h.length > 1 && (h = e.$el.find(p.el), h.length > 1 && (h = h.filter(m => x(m).parents(".swiper")[0] === e.el))), p.type === "bullets" && p.clickable && h.addClass(p.clickableClass), h.addClass(p.modifierClass + p.type), h.addClass(e.isHorizontal() ? p.horizontalClass : p.verticalClass), p.type === "bullets" && p.dynamicBullets && (h.addClass(`${p.modifierClass}${p.type}-dynamic`), l = 0, p.dynamicMainBullets < 1 && (p.dynamicMainBullets = 1)), p.type === "progressbar" && p.progressbarOpposite && h.addClass(p.progressbarOppositeClass), p.clickable && h.on("click", J(p.bulletClass), function(b) {
            b.preventDefault();
            let S = x(this).index() * e.params.slidesPerGroup;
            e.params.loop && (S += e.loopedSlides), e.slideTo(S)
        }), Object.assign(e.pagination, {
            $el: h,
            el: h[0]
        }), e.enabled || h.addClass(p.lockClass))
    }

    function u() {
        const p = e.params.pagination;
        if (d()) return;
        const h = e.pagination.$el;
        h.removeClass(p.hiddenClass), h.removeClass(p.modifierClass + p.type), h.removeClass(e.isHorizontal() ? p.horizontalClass : p.verticalClass), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(p.bulletActiveClass), p.clickable && h.off("click", J(p.bulletClass))
    }
    t("init", () => {
        e.params.pagination.enabled === !1 ? v() : (f(), c(), o())
    }), t("activeIndexChange", () => {
        (e.params.loop || typeof e.snapIndex > "u") && o()
    }), t("snapIndexChange", () => {
        e.params.loop || o()
    }), t("slidesLengthChange", () => {
        e.params.loop && (c(), o())
    }), t("snapGridLengthChange", () => {
        e.params.loop || (c(), o())
    }), t("destroy", () => {
        u()
    }), t("enable disable", () => {
        const {
            $el: p
        } = e.pagination;
        p && p[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass)
    }), t("lock unlock", () => {
        o()
    }), t("click", (p, h) => {
        const m = h.target,
            {
                $el: b
            } = e.pagination;
        if (e.params.pagination.el && e.params.pagination.hideOnClick && b && b.length > 0 && !x(m).hasClass(e.params.pagination.bulletClass)) {
            if (e.navigation && (e.navigation.nextEl && m === e.navigation.nextEl || e.navigation.prevEl && m === e.navigation.prevEl)) return;
            const S = b.hasClass(e.params.pagination.hiddenClass);
            i(S === !0 ? "paginationShow" : "paginationHide"), b.toggleClass(e.params.pagination.hiddenClass)
        }
    });
    const g = () => {
            e.$el.removeClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.removeClass(e.params.pagination.paginationDisabledClass), f(), c(), o()
        },
        v = () => {
            e.$el.addClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.addClass(e.params.pagination.paginationDisabledClass), u()
        };
    Object.assign(e.pagination, {
        enable: g,
        disable: v,
        render: c,
        update: o,
        init: f,
        destroy: u
    })
}

function Ti({
    swiper: e,
    extendParams: n,
    emit: t,
    once: i
}) {
    n({
        freeMode: {
            enabled: !1,
            momentum: !0,
            momentumRatio: 1,
            momentumBounce: !0,
            momentumBounceRatio: 1,
            momentumVelocityRatio: 1,
            sticky: !1,
            minimumVelocity: .02
        }
    });

    function s() {
        const d = e.getTranslate();
        e.setTranslate(d), e.setTransition(0), e.touchEventsData.velocities.length = 0, e.freeMode.onTouchEnd({
            currentPos: e.rtl ? e.translate : -e.translate
        })
    }

    function r() {
        const {
            touchEventsData: d,
            touches: a
        } = e;
        d.velocities.length === 0 && d.velocities.push({
            position: a[e.isHorizontal() ? "startX" : "startY"],
            time: d.touchStartTime
        }), d.velocities.push({
            position: a[e.isHorizontal() ? "currentX" : "currentY"],
            time: q()
        })
    }

    function l({
        currentPos: d
    }) {
        const {
            params: a,
            $wrapperEl: o,
            rtlTranslate: c,
            snapGrid: f,
            touchEventsData: u
        } = e, v = q() - u.touchStartTime;
        if (d < -e.minTranslate()) {
            e.slideTo(e.activeIndex);
            return
        }
        if (d > -e.maxTranslate()) {
            e.slides.length < f.length ? e.slideTo(f.length - 1) : e.slideTo(e.slides.length - 1);
            return
        }
        if (a.freeMode.momentum) {
            if (u.velocities.length > 1) {
                const M = u.velocities.pop(),
                    P = u.velocities.pop(),
                    $ = M.position - P.position,
                    I = M.time - P.time;
                e.velocity = $ / I, e.velocity /= 2, Math.abs(e.velocity) < a.freeMode.minimumVelocity && (e.velocity = 0), (I > 150 || q() - M.time > 300) && (e.velocity = 0)
            } else e.velocity = 0;
            e.velocity *= a.freeMode.momentumVelocityRatio, u.velocities.length = 0;
            let p = 1e3 * a.freeMode.momentumRatio;
            const h = e.velocity * p;
            let m = e.translate + h;
            c && (m = -m);
            let b = !1,
                S;
            const C = Math.abs(e.velocity) * 20 * a.freeMode.momentumBounceRatio;
            let T;
            if (m < e.maxTranslate()) a.freeMode.momentumBounce ? (m + e.maxTranslate() < -C && (m = e.maxTranslate() - C), S = e.maxTranslate(), b = !0, u.allowMomentumBounce = !0) : m = e.maxTranslate(), a.loop && a.centeredSlides && (T = !0);
            else if (m > e.minTranslate()) a.freeMode.momentumBounce ? (m - e.minTranslate() > C && (m = e.minTranslate() + C), S = e.minTranslate(), b = !0, u.allowMomentumBounce = !0) : m = e.minTranslate(), a.loop && a.centeredSlides && (T = !0);
            else if (a.freeMode.sticky) {
                let M;
                for (let P = 0; P < f.length; P += 1)
                    if (f[P] > -m) {
                        M = P;
                        break
                    }
                Math.abs(f[M] - m) < Math.abs(f[M - 1] - m) || e.swipeDirection === "next" ? m = f[M] : m = f[M - 1], m = -m
            }
            if (T && i("transitionEnd", () => {
                    e.loopFix()
                }), e.velocity !== 0) {
                if (c ? p = Math.abs((-m - e.translate) / e.velocity) : p = Math.abs((m - e.translate) / e.velocity), a.freeMode.sticky) {
                    const M = Math.abs((c ? -m : m) - e.translate),
                        P = e.slidesSizesGrid[e.activeIndex];
                    M < P ? p = a.speed : M < 2 * P ? p = a.speed * 1.5 : p = a.speed * 2.5
                }
            } else if (a.freeMode.sticky) {
                e.slideToClosest();
                return
            }
            a.freeMode.momentumBounce && b ? (e.updateProgress(S), e.setTransition(p), e.setTranslate(m), e.transitionStart(!0, e.swipeDirection), e.animating = !0, o.transitionEnd(() => {
                !e || e.destroyed || !u.allowMomentumBounce || (t("momentumBounce"), e.setTransition(a.speed), setTimeout(() => {
                    e.setTranslate(S), o.transitionEnd(() => {
                        !e || e.destroyed || e.transitionEnd()
                    })
                }, 0))
            })) : e.velocity ? (t("_freeModeNoMomentumRelease"), e.updateProgress(m), e.setTransition(p), e.setTranslate(m), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, o.transitionEnd(() => {
                !e || e.destroyed || e.transitionEnd()
            }))) : e.updateProgress(m), e.updateActiveIndex(), e.updateSlidesClasses()
        } else if (a.freeMode.sticky) {
            e.slideToClosest();
            return
        } else a.freeMode && t("_freeModeNoMomentumRelease");
        (!a.freeMode.momentum || v >= a.longSwipesMs) && (e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses())
    }
    Object.assign(e, {
        freeMode: {
            onTouchStart: s,
            onTouchMove: r,
            onTouchEnd: l
        }
    })
}

function Ci({
    swiper: e,
    extendParams: n
}) {
    n({
        grid: {
            rows: 1,
            fill: "column"
        }
    });
    let t, i, s;
    const r = a => {
            const {
                slidesPerView: o
            } = e.params, {
                rows: c,
                fill: f
            } = e.params.grid;
            i = t / c, s = Math.floor(a / c), Math.floor(a / c) === a / c ? t = a : t = Math.ceil(a / c) * c, o !== "auto" && f === "row" && (t = Math.max(t, o * c))
        },
        l = (a, o, c, f) => {
            const {
                slidesPerGroup: u,
                spaceBetween: g
            } = e.params, {
                rows: v,
                fill: p
            } = e.params.grid;
            let h, m, b;
            if (p === "row" && u > 1) {
                const S = Math.floor(a / (u * v)),
                    C = a - v * u * S,
                    T = S === 0 ? u : Math.min(Math.ceil((c - S * v * u) / v), u);
                b = Math.floor(C / T), m = C - b * T + S * u, h = m + b * t / v, o.css({
                    "-webkit-order": h,
                    order: h
                })
            } else p === "column" ? (m = Math.floor(a / v), b = a - m * v, (m > s || m === s && b === v - 1) && (b += 1, b >= v && (b = 0, m += 1))) : (b = Math.floor(a / i), m = a - b * i);
            o.css(f("margin-top"), b !== 0 ? g && `${g}px` : "")
        },
        d = (a, o, c) => {
            const {
                spaceBetween: f,
                centeredSlides: u,
                roundLengths: g
            } = e.params, {
                rows: v
            } = e.params.grid;
            if (e.virtualSize = (a + f) * t, e.virtualSize = Math.ceil(e.virtualSize / v) - f, e.$wrapperEl.css({
                    [c("width")]: `${e.virtualSize+f}px`
                }), u) {
                o.splice(0, o.length);
                const p = [];
                for (let h = 0; h < o.length; h += 1) {
                    let m = o[h];
                    g && (m = Math.floor(m)), o[h] < e.virtualSize + o[0] && p.push(m)
                }
                o.push(...p)
            }
        };
    e.grid = {
        initSlides: r,
        updateSlide: l,
        updateWrapperSize: d
    }
}

function U(e) {
    return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object"
}

function Y(e, n) {
    const t = ["__proto__", "constructor", "prototype"];
    Object.keys(n).filter(i => t.indexOf(i) < 0).forEach(i => {
        typeof e[i] > "u" ? e[i] = n[i] : U(n[i]) && U(e[i]) && Object.keys(n[i]).length > 0 ? n[i].__swiper__ ? e[i] = n[i] : Y(e[i], n[i]) : e[i] = n[i]
    })
}

function We(e = {}) {
    return e.navigation && typeof e.navigation.nextEl > "u" && typeof e.navigation.prevEl > "u"
}

function Ye(e = {}) {
    return e.pagination && typeof e.pagination.el > "u"
}

function qe(e = {}) {
    return e.scrollbar && typeof e.scrollbar.el > "u"
}

function Xe(e = "") {
    const n = e.split(" ").map(i => i.trim()).filter(i => !!i),
        t = [];
    return n.forEach(i => {
        t.indexOf(i) < 0 && t.push(i)
    }), t.join(" ")
}
const Ue = ["modules", "init", "_direction", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_preloadImages", "updateOnImagesReady", "_loop", "_loopAdditionalSlides", "_loopedSlides", "_loopedSlidesLimit", "_loopFillGroupWithBlank", "loopPreventsSlide", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideBlankClass", "slideActiveClass", "slideDuplicateActiveClass", "slideVisibleClass", "slideDuplicateClass", "slideNextClass", "slideDuplicateNextClass", "slidePrevClass", "slideDuplicatePrevClass", "wrapperClass", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "lazy", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom"];

function Ei(e = {}, n = !0) {
    const t = {
            on: {}
        },
        i = {},
        s = {};
    Y(t, ee.defaults), Y(t, ee.extendedDefaults), t._emitClasses = !0, t.init = !1;
    const r = {},
        l = Ue.map(a => a.replace(/_/, "")),
        d = Object.assign({}, e);
    return Object.keys(d).forEach(a => {
        typeof e[a] > "u" || (l.indexOf(a) >= 0 ? U(e[a]) ? (t[a] = {}, s[a] = {}, Y(t[a], e[a]), Y(s[a], e[a])) : (t[a] = e[a], s[a] = e[a]) : a.search(/on[A-Z]/) === 0 && typeof e[a] == "function" ? n ? i[`${a[2].toLowerCase()}${a.substr(3)}`] = e[a] : t.on[`${a[2].toLowerCase()}${a.substr(3)}`] = e[a] : r[a] = e[a])
    }), ["navigation", "pagination", "scrollbar"].forEach(a => {
        t[a] === !0 && (t[a] = {}), t[a] === !1 && delete t[a]
    }), {
        params: t,
        passedParams: s,
        rest: r,
        events: i
    }
}

function wi({
    el: e,
    nextEl: n,
    prevEl: t,
    paginationEl: i,
    scrollbarEl: s,
    swiper: r
}, l) {
    We(l) && n && t && (r.params.navigation.nextEl = n, r.originalParams.navigation.nextEl = n, r.params.navigation.prevEl = t, r.originalParams.navigation.prevEl = t), Ye(l) && i && (r.params.pagination.el = i, r.originalParams.pagination.el = i), qe(l) && s && (r.params.scrollbar.el = s, r.originalParams.scrollbar.el = s), r.init(e)
}
const Ke = (e, n) => {
    let t = n.slidesPerView;
    if (n.breakpoints) {
        const s = ee.prototype.getBreakpoint(n.breakpoints),
            r = s in n.breakpoints ? n.breakpoints[s] : void 0;
        r && r.slidesPerView && (t = r.slidesPerView)
    }
    let i = Math.ceil(parseFloat(n.loopedSlides || t, 10));
    return i += n.loopAdditionalSlides, i > e.length && n.loopedSlidesLimit && (i = e.length), i
};

function yi(e, n, t) {
    const i = n.map((a, o) => L.cloneElement(a, {
        swiper: e,
        "data-swiper-slide-index": o
    }));

    function s(a, o, c) {
        return L.cloneElement(a, {
            key: `${a.key}-duplicate-${o}-${c}`,
            className: `${a.props.className||""} ${t.slideDuplicateClass}`
        })
    }
    if (t.loopFillGroupWithBlank) {
        const a = t.slidesPerGroup - i.length % t.slidesPerGroup;
        if (a !== t.slidesPerGroup)
            for (let o = 0; o < a; o += 1) {
                const c = L.createElement("div", {
                    className: `${t.slideClass} ${t.slideBlankClass}`
                });
                i.push(c)
            }
    }
    t.slidesPerView === "auto" && !t.loopedSlides && (t.loopedSlides = i.length);
    const r = Ke(i, t),
        l = [],
        d = [];
    for (let a = 0; a < r; a += 1) {
        const o = a - Math.floor(a / i.length) * i.length;
        d.push(s(i[o], a, "append")), l.unshift(s(i[i.length - o - 1], a, "prepend"))
    }
    return e && (e.loopedSlides = r), [...l, ...i, ...d]
}

function Mi(e, n, t, i, s) {
    const r = [];
    if (!n) return r;
    const l = a => {
        r.indexOf(a) < 0 && r.push(a)
    };
    if (t && i) {
        const a = i.map(s),
            o = t.map(s);
        a.join("") !== o.join("") && l("children"), i.length !== t.length && l("children")
    }
    return Ue.filter(a => a[0] === "_").map(a => a.replace(/_/, "")).forEach(a => {
        if (a in e && a in n)
            if (U(e[a]) && U(n[a])) {
                const o = Object.keys(e[a]),
                    c = Object.keys(n[a]);
                o.length !== c.length ? l(a) : (o.forEach(f => {
                    e[a][f] !== n[a][f] && l(a)
                }), c.forEach(f => {
                    e[a][f] !== n[a][f] && l(a)
                }))
            } else e[a] !== n[a] && l(a)
    }), r
}

function Qe(e) {
    return e.type && e.type.displayName && e.type.displayName.includes("SwiperSlide")
}

function Je(e) {
    const n = [];
    return L.Children.toArray(e).forEach(t => {
        Qe(t) ? n.push(t) : t.props && t.props.children && Je(t.props.children).forEach(i => n.push(i))
    }), n
}

function _i(e) {
    const n = [],
        t = {
            "container-start": [],
            "container-end": [],
            "wrapper-start": [],
            "wrapper-end": []
        };
    return L.Children.toArray(e).forEach(i => {
        if (Qe(i)) n.push(i);
        else if (i.props && i.props.slot && t[i.props.slot]) t[i.props.slot].push(i);
        else if (i.props && i.props.children) {
            const s = Je(i.props.children);
            s.length > 0 ? s.forEach(r => n.push(r)) : t["container-end"].push(i)
        } else t["container-end"].push(i)
    }), {
        slides: n,
        slots: t
    }
}

function $i({
    swiper: e,
    slides: n,
    passedParams: t,
    changedParams: i,
    nextEl: s,
    prevEl: r,
    scrollbarEl: l,
    paginationEl: d
}) {
    const a = i.filter(T => T !== "children" && T !== "direction"),
        {
            params: o,
            pagination: c,
            navigation: f,
            scrollbar: u,
            virtual: g,
            thumbs: v
        } = e;
    let p, h, m, b, S;
    i.includes("thumbs") && t.thumbs && t.thumbs.swiper && o.thumbs && !o.thumbs.swiper && (p = !0), i.includes("controller") && t.controller && t.controller.control && o.controller && !o.controller.control && (h = !0), i.includes("pagination") && t.pagination && (t.pagination.el || d) && (o.pagination || o.pagination === !1) && c && !c.el && (m = !0), i.includes("scrollbar") && t.scrollbar && (t.scrollbar.el || l) && (o.scrollbar || o.scrollbar === !1) && u && !u.el && (b = !0), i.includes("navigation") && t.navigation && (t.navigation.prevEl || r) && (t.navigation.nextEl || s) && (o.navigation || o.navigation === !1) && f && !f.prevEl && !f.nextEl && (S = !0);
    const C = T => {
        e[T] && (e[T].destroy(), T === "navigation" ? (o[T].prevEl = void 0, o[T].nextEl = void 0, e[T].prevEl = void 0, e[T].nextEl = void 0) : (o[T].el = void 0, e[T].el = void 0))
    };
    a.forEach(T => {
        if (U(o[T]) && U(t[T])) Y(o[T], t[T]);
        else {
            const M = t[T];
            (M === !0 || M === !1) && (T === "navigation" || T === "pagination" || T === "scrollbar") ? M === !1 && C(T): o[T] = t[T]
        }
    }), a.includes("controller") && !h && e.controller && e.controller.control && o.controller && o.controller.control && (e.controller.control = o.controller.control), i.includes("children") && n && g && o.virtual.enabled ? (g.slides = n, g.update(!0)) : i.includes("children") && e.lazy && e.params.lazy.enabled && e.lazy.load(), p && v.init() && v.update(!0), h && (e.controller.control = o.controller.control), m && (d && (o.pagination.el = d), c.init(), c.render(), c.update()), b && (l && (o.scrollbar.el = l), u.init(), u.updateSize(), u.setTranslate()), S && (s && (o.navigation.nextEl = s), r && (o.navigation.prevEl = r), f.init(), f.update()), i.includes("allowSlideNext") && (e.allowSlideNext = t.allowSlideNext), i.includes("allowSlidePrev") && (e.allowSlidePrev = t.allowSlidePrev), i.includes("direction") && e.changeDirection(t.direction, !1), e.update()
}

function Oi(e, n, t) {
    if (!t) return null;
    const i = e.isHorizontal() ? {
        [e.rtlTranslate ? "right" : "left"]: `${t.offset}px`
    } : {
        top: `${t.offset}px`
    };
    return n.filter((s, r) => r >= t.from && r <= t.to).map(s => L.cloneElement(s, {
        swiper: e,
        style: i
    }))
}
const Pi = e => {
    !e || e.destroyed || !e.params.virtual || e.params.virtual && !e.params.virtual.enabled || (e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.lazy && e.params.lazy.enabled && e.lazy.load(), e.parallax && e.params.parallax && e.params.parallax.enabled && e.parallax.setTranslate())
};

function ne(e, n) {
    return typeof window > "u" ? O.useEffect(e, n) : O.useLayoutEffect(e, n)
}
const Ze = O.createContext(null),
    ki = () => O.useContext(Ze),
    et = O.createContext(null),
    Li = () => O.useContext(et);

function xe() {
    return xe = Object.assign ? Object.assign.bind() : function(e) {
        for (var n = 1; n < arguments.length; n++) {
            var t = arguments[n];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
        }
        return e
    }, xe.apply(this, arguments)
}
const tt = O.forwardRef(function(e, n) {
    let {
        className: t,
        tag: i = "div",
        wrapperTag: s = "div",
        children: r,
        onSwiper: l,
        ...d
    } = e === void 0 ? {} : e, a = !1;
    const [o, c] = O.useState("swiper"), [f, u] = O.useState(null), [g, v] = O.useState(!1), p = O.useRef(!1), h = O.useRef(null), m = O.useRef(null), b = O.useRef(null), S = O.useRef(null), C = O.useRef(null), T = O.useRef(null), M = O.useRef(null), P = O.useRef(null), {
        params: $,
        passedParams: I,
        rest: w,
        events: E
    } = Ei(d), {
        slides: _,
        slots: k
    } = _i(r), K = () => {
        v(!g)
    };
    Object.assign($.on, {
        _containerClasses(D, Q) {
            c(Q)
        }
    });
    const te = () => {
        if (Object.assign($.on, E), a = !0, m.current = new ee($), m.current.loopCreate = () => {}, m.current.loopDestroy = () => {}, $.loop && (m.current.loopedSlides = Ke(_, $)), m.current.virtual && m.current.params.virtual.enabled) {
            m.current.virtual.slides = _;
            const D = {
                cache: !1,
                slides: _,
                renderExternal: u,
                renderExternalUpdate: !1
            };
            Y(m.current.params.virtual, D), Y(m.current.originalParams.virtual, D)
        }
    };
    h.current || te(), m.current && m.current.on("_beforeBreakpoint", K);
    const ue = () => {
            a || !E || !m.current || Object.keys(E).forEach(D => {
                m.current.on(D, E[D])
            })
        },
        fe = () => {
            !E || !m.current || Object.keys(E).forEach(D => {
                m.current.off(D, E[D])
            })
        };
    O.useEffect(() => () => {
        m.current && m.current.off("_beforeBreakpoint", K)
    }), O.useEffect(() => {
        !p.current && m.current && (m.current.emitSlidesClasses(), p.current = !0)
    }), ne(() => {
        if (n && (n.current = h.current), !!h.current) return m.current.destroyed && te(), wi({
            el: h.current,
            nextEl: C.current,
            prevEl: T.current,
            paginationEl: M.current,
            scrollbarEl: P.current,
            swiper: m.current
        }, $), l && l(m.current), () => {
            m.current && !m.current.destroyed && m.current.destroy(!0, !1)
        }
    }, []), ne(() => {
        ue();
        const D = Mi(I, b.current, _, S.current, Q => Q.key);
        return b.current = I, S.current = _, D.length && m.current && !m.current.destroyed && $i({
            swiper: m.current,
            slides: _,
            passedParams: I,
            changedParams: D,
            nextEl: C.current,
            prevEl: T.current,
            scrollbarEl: P.current,
            paginationEl: M.current
        }), () => {
            fe()
        }
    }), ne(() => {
        Pi(m.current)
    }, [f]);

    function ae() {
        return $.virtual ? Oi(m.current, _, f) : !$.loop || m.current && m.current.destroyed ? _.map(D => L.cloneElement(D, {
            swiper: m.current
        })) : yi(m.current, _, $)
    }
    return L.createElement(i, xe({
        ref: h,
        className: Xe(`${o}${t?` ${t}`:""}`)
    }, w), L.createElement(et.Provider, {
        value: m.current
    }, k["container-start"], L.createElement(s, {
        className: "swiper-wrapper"
    }, k["wrapper-start"], ae(), k["wrapper-end"]), We($) && L.createElement(L.Fragment, null, L.createElement("div", {
        ref: T,
        className: "swiper-button-prev"
    }), L.createElement("div", {
        ref: C,
        className: "swiper-button-next"
    })), qe($) && L.createElement("div", {
        ref: P,
        className: "swiper-scrollbar"
    }), Ye($) && L.createElement("div", {
        ref: M,
        className: "swiper-pagination"
    }), k["container-end"]))
});
tt.displayName = "Swiper";

function Te() {
    return Te = Object.assign ? Object.assign.bind() : function(e) {
        for (var n = 1; n < arguments.length; n++) {
            var t = arguments[n];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
        }
        return e
    }, Te.apply(this, arguments)
}
const we = O.forwardRef(function(e, n) {
    let {
        tag: t = "div",
        children: i,
        className: s = "",
        swiper: r,
        zoom: l,
        virtualIndex: d,
        ...a
    } = e === void 0 ? {} : e;
    const o = O.useRef(null),
        [c, f] = O.useState("swiper-slide");

    function u(p, h, m) {
        h === o.current && f(m)
    }
    ne(() => {
        if (n && (n.current = o.current), !(!o.current || !r)) {
            if (r.destroyed) {
                c !== "swiper-slide" && f("swiper-slide");
                return
            }
            return r.on("_slideClass", u), () => {
                r && r.off("_slideClass", u)
            }
        }
    }), ne(() => {
        r && o.current && !r.destroyed && f(r.getSlideClasses(o.current))
    }, [r]);
    const g = {
            isActive: c.indexOf("swiper-slide-active") >= 0 || c.indexOf("swiper-slide-duplicate-active") >= 0,
            isVisible: c.indexOf("swiper-slide-visible") >= 0,
            isDuplicate: c.indexOf("swiper-slide-duplicate") >= 0,
            isPrev: c.indexOf("swiper-slide-prev") >= 0 || c.indexOf("swiper-slide-duplicate-prev") >= 0,
            isNext: c.indexOf("swiper-slide-next") >= 0 || c.indexOf("swiper-slide-duplicate-next") >= 0
        },
        v = () => typeof i == "function" ? i(g) : i;
    return L.createElement(t, Te({
        ref: o,
        className: Xe(`${c}${s?` ${s}`:""}`),
        "data-swiper-slide-index": d
    }, a), L.createElement(Ze.Provider, {
        value: g
    }, l ? L.createElement("div", {
        className: "swiper-zoom-container",
        "data-swiper-zoom": typeof l == "number" ? l : void 0
    }, v()) : v()))
});
we.displayName = "SwiperSlide";

function V({
    children: e,
    ...n
}) {
    const t = O.useRef(null),
        {
            isMobile: i,
            isTablet: s,
            isDesktop: r,
            isLargeScreen: l,
            isUpMd: d
        } = mt(),
        {
            navigation: a,
            pagination: o
        } = n,
        c = {
            prevEl: ".swiper-prev-ww-selector",
            nextEl: ".swiper-next-ww-selector"
        },
        f = {
            el: ".swiper-pagination-ww-selector"
        };
    return O.useEffect(() => {
        t.current && (t.current.pagination && (t.current.pagination.destroy(), t.current.pagination.init(), t.current.pagination.render(), t.current.pagination.update()), t.current.navigation)
    }, [i, s, r, l, d]), y(tt, { ...n,
        onSwiper: u => {
            t.current = u
        },
        modules: [Si, xi, Ci, Ti],
        navigation: a && { ...Ne(a),
            ...c
        },
        pagination: o && { ...Ne(o),
            ...f
        },
        children: e
    })
}
const Ne = e => e === !0 ? {} : e,
    Ni = ({
        className: e,
        children: n,
        ...t
    }) => y("button", {
        className: j("swiper-prev-ww-selector", e),
        ...t,
        children: n
    }),
    Ii = ({
        className: e,
        children: n,
        ...t
    }) => y("button", {
        className: j("swiper-next-ww-selector", e),
        ...t,
        children: n
    }),
    Di = ({
        className: e,
        children: n
    }) => y("div", {
        className: j("swiper-pagination-ww-selector", e),
        children: n
    }),
    nt = ({
        children: e,
        ...n
    }) => {
        const {
            originalParams: {
                spaceBetween: t
            }
        } = Li();
        return y(we, { ...n,
            style: {
                marginRight: t ? `${t}px` : void 0,
                ...n.style
            },
            children: e
        })
    };
nt.displayName = we.displayName;
V.Prev = Ni;
V.Next = Ii;
V.Pages = Di;
V.Slide = nt;

function it({
    event: e,
    ...n
}) {
    const t = O.useRef(),
        {
            ref: i,
            ...s
        } = at({
            threshold: .3,
            ...n,
            onChange: l => {
                l && lt(e, t.current)
            }
        }),
        r = O.useCallback(l => {
            t.current = l, i(l)
        }, [i]);
    return { ...s,
        ref: r
    }
}
const ss = "sm2:px-40 px-24 mx-auto max-w-[1280px]",
    rs = "font-set-b24 md:font-set-b28",
    as = "!-mx-8 !px-8",
    zi = "!-mx-12 !px-12 !py-8 md:!py-12",
    ls = "!w-[calc((100%+12px)/3-12px)] xs2:!w-132 sm2:!w-[calc((100%+12px)/5-12px)] md:!w-[calc((100%+16px)/5-16px)] lg:!w-[calc((100%+16px)/7-16px)]",
    os = "bg-clip-content w-14 h-14 p-4 rounded-full bg-black/20 dark:bg-white/40 cursor-default md:cursor-pointer pointer-events-none md:pointer-events-auto",
    ds = "!bg-blue-600",
    Ie = "rounded-8 p-4 text-gray-800 dark:bg-gray-850 dark:text-white shadow-ww-nav-button disabled:text-gray-400 dark:disabled:text-white/20",
    Ai = "font-set-b13 md:font-set-b16",
    Bi = "font-set-sb13 md:font-set-sb15",
    Ri = "font-set-m16 md:font-set-m18",
    cs = ["bg-[#D6E2F1] bg-ww-genre-color-0", "bg-[#D7E7EC] bg-ww-genre-color-1", "bg-[#D8ECE3] bg-ww-genre-color-2", "bg-[#DCE2CF] bg-ww-genre-color-3", "bg-[#E8DACF] bg-ww-genre-color-4", "bg-[#D5DBE6] bg-ww-genre-color-5", "bg-[#D4DAED] bg-ww-genre-color-6", "bg-[#D8D3E9] bg-ww-genre-color-7", "bg-[#E0D3E8] bg-ww-genre-color-8"];

function ie({
    children: e,
    isLoading: n,
    ...t
}) {
    const {
        ref: i
    } = it({
        event: Z.ViewCollection,
        triggerOnce: !0,
        skip: n
    });
    return y("article", {
        ref: i,
        className: "py-12 md:pb-0",
        ...t,
        children: e
    })
}
const Gi = ({
        title: e,
        classes: n,
        isLoading: t
    }) => y(de, {
        className: n == null ? void 0 : n.skeleton,
        item: !t,
        skeletonProps: se,
        children: y("h1", {
            className: X("text-gray-t1", n == null ? void 0 : n.heading),
            children: e
        })
    }),
    Hi = ({
        title: e,
        classes: n,
        isLoading: t
    }) => y(de, {
        className: n == null ? void 0 : n.skeleton,
        item: !t,
        skeletonProps: se,
        children: y("h2", {
            className: X("text-gray-desc", n == null ? void 0 : n.heading),
            children: e
        })
    });
ie.Title = Gi;
ie.SubTitle = Hi;
const be = {
        "ranking-number": "_ranking-number_1p89n_1",
        "ranking-number-mobile": "_ranking-number-mobile_1p89n_8",
        "ranking-number-10_3x": "_ranking-number-10_3x_1p89n_12",
        "ranking-number-11_3x": "_ranking-number-11_3x_1p89n_18",
        "ranking-number-12_3x": "_ranking-number-12_3x_1p89n_24",
        "ranking-number-13_3x": "_ranking-number-13_3x_1p89n_30",
        "ranking-number-14_3x": "_ranking-number-14_3x_1p89n_36",
        "ranking-number-1_3x": "_ranking-number-1_3x_1p89n_42",
        "ranking-number-2_3x": "_ranking-number-2_3x_1p89n_48",
        "ranking-number-3_3x": "_ranking-number-3_3x_1p89n_54",
        "ranking-number-4_3x": "_ranking-number-4_3x_1p89n_60",
        "ranking-number-5_3x": "_ranking-number-5_3x_1p89n_66",
        "ranking-number-6_3x": "_ranking-number-6_3x_1p89n_72",
        "ranking-number-7_3x": "_ranking-number-7_3x_1p89n_78",
        "ranking-number-8_3x": "_ranking-number-8_3x_1p89n_84",
        "ranking-number-9_3x": "_ranking-number-9_3x_1p89n_90"
    },
    Vi = {
        goodIcon: "w-12 h-12",
        score: "ml-2"
    };

function G({
    content: e,
    children: n,
    isLoading: t,
    viewLogDisabled: i,
    clickEvent: s
}) {
    const {
        ref: r
    } = it({
        event: Z.ViewCollectionItem,
        triggerOnce: !0,
        skip: i || t
    }), {
        reviewRating: l
    } = ze({
        novel: e
    }), d = O.useMemo(() => ({
        content: e,
        reviewRating: l,
        isLoading: t,
        clickEvent: s
    }), [e, l, t, s]);
    return y(ce.Provider, {
        value: d,
        children: y("section", {
            ref: r,
            children: n
        })
    })
}
const ce = O.createContext({}),
    Fi = ({
        rank: e,
        srcWidth: n,
        srcHeight: t,
        classes: i,
        showStatus: s
    }) => {
        var c, f;
        const {
            content: r,
            isLoading: l,
            clickEvent: d
        } = O.useContext(ce), {
            activePricingModelType: a
        } = ze({
            novel: r
        }), {
            isVisible: o = !0
        } = ki();
        return y(De, {
            className: i == null ? void 0 : i.link,
            to: Ae((r == null ? void 0 : r.slug) || ""),
            "data-amplitude-click-event": d ? ? Z.ClickCollectionItem,
            children: y("div", {
                className: X("relative h-0 pb-[146%]", i == null ? void 0 : i.container),
                children: F(Me, {
                    novel: r,
                    imgUrl: (c = r == null ? void 0 : r.coverUrl) == null ? void 0 : c.value,
                    imgBlurHash: (f = r == null ? void 0 : r.coverBlurHash) == null ? void 0 : f.value,
                    isLoading: l,
                    srcWidth: n ? ? 200,
                    srcHeight: t ? ? 292,
                    classes: {
                        bookCover: "rounded-r-5",
                        img: j("rounded-r-5", o && "drop-shadow-ww-home-content-image", i == null ? void 0 : i.img)
                    },
                    children: [a === "waitToUnlock" && y(Me.WtuBadge, {
                        classes: {
                            root: "bottom-4 right-4 md:bottom-5 md:right-5",
                            box: "h-24 w-24 md:h-28 md:w-28",
                            icon: "h-16 w-16 md:h-20 md:w-20",
                            ...i == null ? void 0 : i.badge
                        }
                    }), e !== void 0 && y(ji, {
                        rank: e
                    }), (r == null ? void 0 : r.status) !== void 0 && s !== !1 && y("div", {
                        className: "font-set-b9 bg-gray-950/50 absolute top-0 rounded-[0_0_4px_0] py-4 px-6 text-white",
                        children: ot(r.status)
                    })]
                })
            })
        })
    },
    ji = ({
        rank: e
    }) => {
        const n = dt(B.downMd, {
            noSsr: !0
        });
        return y("div", {
            className: "absolute -bottom-2 -left-2",
            children: y("span", {
                className: j(be["ranking-number"], be[`ranking-number-${e+1}_3x`], n && be["ranking-number-mobile"])
            })
        })
    },
    Wi = ({
        className: e,
        classes: n,
        text: t
    }) => y("div", {
        className: X("w-full rounded-b-md", e),
        children: y("span", {
            className: X("m-4 text-[12px] font-semibold dark:text-white", n == null ? void 0 : n.text),
            children: t
        })
    }),
    Yi = ({
        className: e,
        classes: n,
        children: t
    }) => {
        const {
            reviewRating: i,
            isLoading: s
        } = O.useContext(ce);
        return i === void 0 ? null : y(de, {
            item: !s,
            skeletonProps: se,
            className: "h-14 w-48 md:h-16 md:w-64",
            children: y("div", {
                className: e,
                children: y(ht, {
                    reviewRating: i,
                    classes: n ? ? Vi,
                    children: t
                })
            })
        })
    },
    qi = ({
        className: e
    }) => {
        const {
            content: n,
            isLoading: t,
            clickEvent: i
        } = O.useContext(ce);
        return y(de, {
            item: !t,
            count: 2,
            className: "mt-4 h-12 last:w-96 md:h-14",
            skeletonProps: se,
            children: y(De, {
                to: Ae((n == null ? void 0 : n.slug) || ""),
                className: X("line-clamp-2", e),
                "data-amplitude-click-event": i ? ? Z.ClickCollectionItem,
                children: n == null ? void 0 : n.name
            })
        })
    },
    Xi = ({
        className: e,
        subtitle: n
    }) => y("span", {
        className: j("text-[#E0E0E0]", e),
        children: n
    }),
    Ui = ({
        className: e,
        children: n
    }) => y("div", {
        className: j("text-gray-t2 px-4 pt-4", e),
        children: n
    });
G.Image = Fi;
G.TextWrapper = Ui;
G.ReviewScore = Yi;
G.Title = qi;
G.SubTitle = Xi;
G.Banner = Wi;

function Ce({
    children: e,
    dark: n,
    ...t
}) {
    const {
        pagination: i,
        spaceBetween: s,
        style: r,
        isLoading: l,
        ...d
    } = t, a = R(B.downMd);
    return F(V, { ...d,
        spaceBetween: s ? ? (a ? 12 : 16),
        style: r ? ? (a ? {
            overflow: "visible"
        } : {}),
        freeMode: !a,
        watchSlidesProgress: !0,
        navigation: !0,
        pagination: i ? ? {
            clickable: !0,
            bulletClass: j("bg-clip-content cursor-pointer w-14 h-14 p-4 rounded-full bg-black/20 dark:bg-white/40", n && "bg-white/40"),
            bulletActiveClass: "!bg-blue-600"
        },
        children: [e, F("div", {
            className: j("flex justify-center", a ? "visibility-hidden pt-0" : "pt-12", l && "visibility-hidden"),
            children: [y(V.Prev, {
                className: X(Ie, n && "bg-gray-850 text-white disabled:text-white/20"),
                "data-amplitude-click-event": Z.ClickPreviousCollectionArrow,
                children: y(ye, {
                    className: "h-16 w-16 -rotate-90"
                })
            }), y(V.Pages, {
                className: "flex !w-auto items-center px-16"
            }), y(V.Next, {
                className: X(Ie, n && "bg-gray-850 text-white disabled:text-white/20"),
                "data-amplitude-click-event": Z.ClickNextCollectionArrow,
                children: y(ye, {
                    className: "h-16 w-16 rotate-90"
                })
            })]
        })]
    })
}
Ce.Slide = V.Slide;

function Ki({
    content: e,
    isLoading: n
}) {
    return F(G, {
        content: e,
        isLoading: n,
        children: [y(G.Image, {
            classes: {
                badge: {
                    box: "h-24 w-24 md:h-36 md:w-36",
                    icon: "h-16 w-16 md:h-24 md:w-24"
                }
            }
        }), F(G.TextWrapper, {
            children: [y(G.ReviewScore, {
                className: Ai
            }), y(G.Title, {
                className: Bi
            })]
        })]
    })
}

function us({
    relatedContent: e,
    contents: n = Array(10).fill({}),
    isLoading: t
}) {
    const {
        coverUrl: i,
        coverBlurHash: s
    } = ct(e), r = Ji(), l = R(B.downLg);
    return F(ie, {
        "data-amplitude-params": JSON.stringify({
            collectionSlot: ut.RelatedRecommendation
        }),
        children: [F("div", {
            className: "flex flex-row items-center space-x-8 py-8",
            children: [y(Qi, {
                coverUrl: i,
                coverBlurHash: s,
                isLoading: t
            }), F("div", {
                className: "flex flex-col",
                children: [y(ie.Title, {
                    title: "Because You Read",
                    classes: {
                        heading: "font-set-b21 md:font-set-b24"
                    },
                    isLoading: t
                }), y(ie.SubTitle, {
                    title: e == null ? void 0 : e.name,
                    classes: {
                        heading: Ri
                    },
                    isLoading: t
                })]
            })]
        }), y(Ce, {
            slidesPerView: r,
            slidesPerGroup: l ? 1 : 6,
            className: zi,
            isLoading: t,
            children: n == null ? void 0 : n.map((d, a) => y(Ce.Slide, {
                className: "!w-[calc((100%+12px)/2.33-12px)] xs2:!w-180 sm2:!w-[calc((100%+12px)/4-12px)] md:!w-[calc((100%+16px)/4-16px)] lg:!w-[calc((100%+16px)/6-16px)]",
                "data-amplitude-params": JSON.stringify({
                    itemSlot: a
                }),
                children: y(Ki, {
                    content: d,
                    isLoading: t
                })
            }, a))
        })]
    })
}
const Qi = ({
        coverUrl: e,
        coverBlurHash: n,
        isLoading: t
    }) => {
        const i = R(B.downSm2);
        return y(ft, {
            item: !t,
            skeletonProps: se,
            children: F("div", {
                className: "relative",
                children: [y(pt, {
                    src: e,
                    blurHash: n,
                    width: i ? 32 : 36,
                    height: i ? 44 : 48,
                    fallbackImage: "/cover.png",
                    lazy: !0,
                    innerClassName: "rounded-6"
                }), y("div", {
                    className: "absolute top-0 left-0 h-full w-full rounded-6 border-[0.5px] border-black/20 bg-black/[.08]"
                })]
            })
        })
    },
    Ji = () => {
        const e = R(B.downXs2),
            n = R(B.downSm2),
            t = R(B.downLg);
        return e ? 2.33 : n ? "auto" : t ? 4 : 6
    };
export {
    Ie as H, us as R, V as S, mt as a, as as b, os as c, ds as d, tt as e, Ti as f, we as g, G as h, Bi as i, ie as j, rs as k, Ce as l, zi as m, ls as n, cs as o, Ri as p, Ai as q, ss as r, Ji as s, it as u
};
//# sourceMappingURL=RelatedRecommends.Su3EijRB.min.js.map