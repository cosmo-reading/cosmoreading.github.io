var N = function(o, l, e, c) {
    function a(t) {
        return t instanceof e ? t : new e(function(r) {
            r(t)
        })
    }
    return new(e || (e = Promise))(function(t, r) {
        function f(n) {
            try {
                w(c.next(n))
            } catch (m) {
                r(m)
            }
        }

        function h(n) {
            try {
                w(c.throw(n))
            } catch (m) {
                r(m)
            }
        }

        function w(n) {
            n.done ? t(n.value) : a(n.value).then(f, h)
        }
        w((c = c.apply(o, l || [])).next())
    })
};

function p(o) {
    let l = 0,
        e = 0,
        c = o;
    do l += c.offsetTop || 0, e += c.offsetLeft || 0, c = c.offsetParent; while (c);
    return {
        top: l,
        left: e
    }
}
class j {
    constructor(l) {
        this.element = l
    }
    getHorizontalScroll() {
        return this.element.scrollLeft
    }
    getVerticalScroll() {
        return this.element.scrollTop
    }
    getMaxHorizontalScroll() {
        return this.element.scrollWidth - this.element.clientWidth
    }
    getMaxVerticalScroll() {
        return this.element.scrollHeight - this.element.clientHeight
    }
    getHorizontalElementScrollOffset(l, e) {
        return p(l).left - p(e).left
    }
    getVerticalElementScrollOffset(l, e) {
        return p(l).top - p(e).top
    }
    scrollTo(l, e) {
        this.element.scrollLeft = l, this.element.scrollTop = e
    }
}
class q {
    constructor() {
        this.element = window
    }
    getHorizontalScroll() {
        return window.scrollX || document.documentElement.scrollLeft
    }
    getVerticalScroll() {
        return window.scrollY || document.documentElement.scrollTop
    }
    getMaxHorizontalScroll() {
        return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth
    }
    getMaxVerticalScroll() {
        return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight
    }
    getHorizontalElementScrollOffset(l) {
        return (window.scrollX || document.documentElement.scrollLeft) + l.getBoundingClientRect().left
    }
    getVerticalElementScrollOffset(l) {
        return (window.scrollY || document.documentElement.scrollTop) + l.getBoundingClientRect().top
    }
    scrollTo(l, e) {
        window.scrollTo(l, e)
    }
}
const i = {
        elements: [],
        cancelMethods: [],
        add: (o, l) => {
            i.elements.push(o), i.cancelMethods.push(l)
        },
        remove: (o, l) => {
            const e = i.elements.indexOf(o);
            e > -1 && (l && i.cancelMethods[e](), i.elements.splice(e, 1), i.cancelMethods.splice(e, 1))
        }
    },
    P = typeof window < "u",
    I = {
        cancelOnUserAction: !0,
        easing: o => --o * o * o + 1,
        elementToScroll: P ? window : null,
        horizontalOffset: 0,
        maxDuration: 3e3,
        minDuration: 250,
        speed: 500,
        verticalOffset: 0
    };

function U(o, l = {}) {
    return N(this, void 0, void 0, function*() {
        if (P) {
            if (!window.Promise) throw "Browser doesn't support Promises, and animated-scroll-to depends on it, please provide a polyfill."
        } else return new Promise(u => {
            u(!1)
        });
        let e, c, a, t = Object.assign(Object.assign({}, I), l);
        const r = t.elementToScroll === window,
            f = !!t.elementToScroll.nodeName;
        if (!r && !f) throw "Element to scroll needs to be either window or DOM element.";
        const h = r ? document.documentElement : t.elementToScroll;
        getComputedStyle(h).getPropertyValue("scroll-behavior") === "smooth" && console.warn(`${h.tagName} has "scroll-behavior: smooth" which can mess up with animated-scroll-to's animations`);
        const n = r ? new q : new j(t.elementToScroll);
        if (o instanceof Element) {
            if (a = o, f && (!t.elementToScroll.contains(a) || t.elementToScroll.isSameNode(a))) throw "options.elementToScroll has to be a parent of scrollToElement";
            e = n.getHorizontalElementScrollOffset(a, t.elementToScroll), c = n.getVerticalElementScrollOffset(a, t.elementToScroll)
        } else if (typeof o == "number") e = n.getHorizontalScroll(), c = o;
        else if (Array.isArray(o) && o.length === 2) e = o[0] === null ? n.getHorizontalScroll() : o[0], c = o[1] === null ? n.getVerticalScroll() : o[1];
        else throw `Wrong function signature. Check documentation.
Available method signatures are:
  animateScrollTo(y:number, options)
  animateScrollTo([x:number | null, y:number | null], options)
  animateScrollTo(scrollToElement:Element, options)`;
        e += t.horizontalOffset, c += t.verticalOffset;
        const m = n.getMaxHorizontalScroll(),
            v = n.getHorizontalScroll();
        e > m && (e = m);
        const g = e - v,
            E = n.getMaxVerticalScroll(),
            H = n.getVerticalScroll();
        c > E && (c = E);
        const T = c - H,
            x = Math.abs(Math.round(g / 1e3 * t.speed)),
            y = Math.abs(Math.round(T / 1e3 * t.speed));
        let d = x > y ? x : y;
        return d < t.minDuration ? d = t.minDuration : d > t.maxDuration && (d = t.maxDuration), new Promise((u, O) => {
            g === 0 && T === 0 && u(!0), i.remove(n.element, !0);
            let S;
            const D = () => {
                V(), cancelAnimationFrame(S), u(!1)
            };
            i.add(n.element, D);
            const _ = s => s.preventDefault(),
                M = t.cancelOnUserAction ? D : _,
                z = t.cancelOnUserAction ? {
                    passive: !0
                } : {
                    passive: !1
                },
                W = ["wheel", "touchstart", "keydown", "mousedown"],
                V = () => {
                    W.forEach(s => {
                        n.element.removeEventListener(s, M, z)
                    })
                };
            W.forEach(s => {
                n.element.addEventListener(s, M, z)
            });
            const F = Date.now(),
                A = () => {
                    var s = Date.now() - F,
                        b = s / d;
                    const L = Math.round(v + g * t.easing(b)),
                        B = Math.round(H + T * t.easing(b));
                    s < d && (L !== e || B !== c) ? (n.scrollTo(L, B), S = requestAnimationFrame(A)) : (n.scrollTo(e, c), cancelAnimationFrame(S), V(), i.remove(n.element, !1), u(!0))
                };
            S = requestAnimationFrame(A)
        })
    })
}
export {
    U as a
};
//# sourceMappingURL=index.D8jIUvOW.min.js.map