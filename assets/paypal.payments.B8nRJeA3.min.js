import {
    r as f,
    ch as A,
    cS as P,
    j as E,
    eG as R,
    bI as D,
    eH as G,
    eI as j
} from "./app.BSN4W8HM.min.js";
import {
    B as L
} from "./stripe.DO7kloeC.min.js";
const S = typeof self < "u" && self.requestIdleCallback || (t => {
        const e = Date.now();
        return setTimeout(() => {
            t({
                didTimeout: !1,
                timeRemaining: () => Math.max(0, 50 - (Date.now() - e))
            })
        }, 1)
    }),
    M = new Map,
    g = new Set,
    x = {
        acceptCharset: "accept-charset",
        className: "class",
        htmlFor: "for",
        httpEquiv: "http-equiv",
        noModule: "noModule"
    },
    H = ["onLoad", "dangerouslySetInnerHTML", "children", "onError", "strategy", "container"],
    b = t => {
        const {
            src: e,
            id: d,
            onLoad: i = () => {},
            dangerouslySetInnerHTML: u,
            children: o = "",
            container: c,
            onError: l
        } = t, s = d || e;
        if (M.has(e)) {
            g.has(s) || (g.add(s), M.get(e).then(i, l));
            return
        }
        const a = document.createElement("script"),
            y = new Promise((n, r) => {
                a.addEventListener("load", () => {
                    n(), i && i()
                }), a.addEventListener("error", () => {
                    r(), l && l()
                })
            }).catch(() => {});
        e && (M.set(e, y), g.add(s)), u ? a.innerHTML = u.__html || "" : o ? a.textContent = typeof o == "string" ? o : Array.isArray(o) ? o.join("") : "" : e && (a.src = e);
        for (const [n, r] of Object.entries(t)) {
            if (r === void 0 || H.includes(n)) continue;
            const m = x[n] || n.toLowerCase();
            a.setAttribute(m, r)
        }
        c ? c.appendChild(a) : document.body.appendChild(a)
    };

function z(t) {
    document.readyState === "complete" ? S(() => b(t)) : window.addEventListener("load", () => {
        S(() => b(t))
    })
}

function B(t) {
    const {
        strategy: e = "afterInteractive"
    } = t;
    return f.useEffect(() => {
        e === "afterInteractive" ? b(t) : e === "lazyOnload" && z(t)
    }, [t, e]), null
}

function F({
    enabled: t,
    mode: e,
    amount: d,
    onSelect: i,
    onError: u
}) {
    const {
        grpcRequest: o
    } = A(), [c, l] = f.useState(!1), s = P(i), a = P(u), y = f.useCallback(() => {
        l(!0)
    }, []);
    return f.useEffect(() => {
        let n;
        const r = () => {
                n == null || n.teardown(() => {
                    n = null
                })
            },
            m = async () => {
                var k;
                const h = await o(L, p => p.getGatewayToken, R.create({
                    gateway: D.Braintree,
                    tokenType: G.AddPaymentMethod
                }));
                if (h.result && ((k = h.token) != null && k.value)) {
                    const p = braintree,
                        T = h.token.value;
                    p.setup(T, "custom", {
                        dataCollector: !0,
                        onReady: v => {
                            n = v, n.paypal.initAuthFlow()
                        },
                        onError: () => {
                            a == null || a("Paypal server reported an error! Please try again later.")
                        },
                        onPaymentMethodReceived: v => {
                            const {
                                nonce: C
                            } = v;
                            e === "vault" ? (async () => {
                                const I = j.create({
                                        paymentMethod: {
                                            oneofKind: "braintree",
                                            braintree: {
                                                nonce: {
                                                    value: C
                                                },
                                                deviceData: {
                                                    value: n.deviceData
                                                }
                                            }
                                        }
                                    }),
                                    w = await o(L, q => q.addPaymentMethod, I);
                                w.result && w.paymentMethodItem && s(w.paymentMethodItem)
                            })() : e === "once" && s(C)
                        },
                        paypal: {
                            currency: "USD",
                            flow: e === "once" ? "checkout" : "vault",
                            amount: e === "once" ? d : void 0,
                            singleUse: e === "once",
                            commit: !0,
                            headless: !0,
                            onAuthorizationDismissed: () => {
                                a == null || a("Authorization Dismissed.")
                            }
                        }
                    })
                }
            };
        return t && (c || typeof braintree < "u") && m(), () => {
            r()
        }
    }, [d, t, o, a, s, e, c]), t ? E(B, {
        src: "https://js.braintreegateway.com/js/braintree-2.32.1.min.js",
        onLoad: y
    }) : null
}
export {
    F as P, S as r
};
//# sourceMappingURL=paypal.payments.B8nRJeA3.min.js.map