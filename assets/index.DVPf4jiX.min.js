var i;
(function(e) {
    e.Root = "root", e.Text = "text", e.Directive = "directive", e.Comment = "comment", e.Script = "script", e.Style = "style", e.Tag = "tag", e.CDATA = "cdata", e.Doctype = "doctype"
})(i || (i = {}));

function T(e) {
    return e.type === i.Tag || e.type === i.Script || e.type === i.Style
}
const A = i.Root,
    k = i.Text,
    P = i.Directive,
    _ = i.Comment,
    j = i.Script,
    O = i.Style,
    R = i.Tag,
    $ = i.CDATA,
    E = i.Doctype;
class u {
    constructor() {
        this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null
    }
    get parentNode() {
        return this.parent
    }
    set parentNode(t) {
        this.parent = t
    }
    get previousSibling() {
        return this.prev
    }
    set previousSibling(t) {
        this.prev = t
    }
    get nextSibling() {
        return this.next
    }
    set nextSibling(t) {
        this.next = t
    }
    cloneNode(t = !1) {
        return g(this, t)
    }
}
class l extends u {
    constructor(t) {
        super(), this.data = t
    }
    get nodeValue() {
        return this.data
    }
    set nodeValue(t) {
        this.data = t
    }
}
class o extends l {
    constructor() {
        super(...arguments), this.type = i.Text
    }
    get nodeType() {
        return 3
    }
}
class p extends l {
    constructor() {
        super(...arguments), this.type = i.Comment
    }
    get nodeType() {
        return 8
    }
}
class f extends l {
    constructor(t, s) {
        super(s), this.name = t, this.type = i.Directive
    }
    get nodeType() {
        return 1
    }
}
class h extends u {
    constructor(t) {
        super(), this.children = t
    }
    get firstChild() {
        var t;
        return (t = this.children[0]) !== null && t !== void 0 ? t : null
    }
    get lastChild() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null
    }
    get childNodes() {
        return this.children
    }
    set childNodes(t) {
        this.children = t
    }
}
class x extends h {
    constructor() {
        super(...arguments), this.type = i.CDATA
    }
    get nodeType() {
        return 4
    }
}
class c extends h {
    constructor() {
        super(...arguments), this.type = i.Root
    }
    get nodeType() {
        return 9
    }
}
class m extends h {
    constructor(t, s, n = [], r = t === "script" ? i.Script : t === "style" ? i.Style : i.Tag) {
        super(n), this.name = t, this.attribs = s, this.type = r
    }
    get nodeType() {
        return 1
    }
    get tagName() {
        return this.name
    }
    set tagName(t) {
        this.name = t
    }
    get attributes() {
        return Object.keys(this.attribs).map(t => {
            var s, n;
            return {
                name: t,
                value: this.attribs[t],
                namespace: (s = this["x-attribsNamespace"]) === null || s === void 0 ? void 0 : s[t],
                prefix: (n = this["x-attribsPrefix"]) === null || n === void 0 ? void 0 : n[t]
            }
        })
    }
}

function b(e) {
    return T(e)
}

function C(e) {
    return e.type === i.CDATA
}

function v(e) {
    return e.type === i.Text
}

function S(e) {
    return e.type === i.Comment
}

function I(e) {
    return e.type === i.Directive
}

function w(e) {
    return e.type === i.Root
}

function D(e) {
    return Object.prototype.hasOwnProperty.call(e, "children")
}

function g(e, t = !1) {
    let s;
    if (v(e)) s = new o(e.data);
    else if (S(e)) s = new p(e.data);
    else if (b(e)) {
        const n = t ? d(e.children) : [],
            r = new m(e.name, { ...e.attribs
            }, n);
        n.forEach(a => a.parent = r), e.namespace != null && (r.namespace = e.namespace), e["x-attribsNamespace"] && (r["x-attribsNamespace"] = { ...e["x-attribsNamespace"]
        }), e["x-attribsPrefix"] && (r["x-attribsPrefix"] = { ...e["x-attribsPrefix"]
        }), s = r
    } else if (C(e)) {
        const n = t ? d(e.children) : [],
            r = new x(n);
        n.forEach(a => a.parent = r), s = r
    } else if (w(e)) {
        const n = t ? d(e.children) : [],
            r = new c(n);
        n.forEach(a => a.parent = r), e["x-mode"] && (r["x-mode"] = e["x-mode"]), s = r
    } else if (I(e)) {
        const n = new f(e.name, e.data);
        e["x-name"] != null && (n["x-name"] = e["x-name"], n["x-publicId"] = e["x-publicId"], n["x-systemId"] = e["x-systemId"]), s = n
    } else throw new Error(`Not implemented yet: ${e.type}`);
    return s.startIndex = e.startIndex, s.endIndex = e.endIndex, e.sourceCodeLocation != null && (s.sourceCodeLocation = e.sourceCodeLocation), s
}

function d(e) {
    const t = e.map(s => g(s, !0));
    for (let s = 1; s < t.length; s++) t[s].prev = t[s - 1], t[s - 1].next = t[s];
    return t
}
const y = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
};
class N {
    constructor(t, s, n) {
        this.dom = [], this.root = new c(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof s == "function" && (n = s, s = y), typeof t == "object" && (s = t, t = void 0), this.callback = t ? ? null, this.options = s ? ? y, this.elementCB = n ? ? null
    }
    onparserinit(t) {
        this.parser = t
    }
    onreset() {
        this.dom = [], this.root = new c(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null
    }
    onend() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null))
    }
    onerror(t) {
        this.handleCallback(t)
    }
    onclosetag() {
        this.lastNode = null;
        const t = this.tagStack.pop();
        this.options.withEndIndices && (t.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(t)
    }
    onopentag(t, s) {
        const n = this.options.xmlMode ? i.Tag : void 0,
            r = new m(t, s, void 0, n);
        this.addNode(r), this.tagStack.push(r)
    }
    ontext(t) {
        const {
            lastNode: s
        } = this;
        if (s && s.type === i.Text) s.data += t, this.options.withEndIndices && (s.endIndex = this.parser.endIndex);
        else {
            const n = new o(t);
            this.addNode(n), this.lastNode = n
        }
    }
    oncomment(t) {
        if (this.lastNode && this.lastNode.type === i.Comment) {
            this.lastNode.data += t;
            return
        }
        const s = new p(t);
        this.addNode(s), this.lastNode = s
    }
    oncommentend() {
        this.lastNode = null
    }
    oncdatastart() {
        const t = new o(""),
            s = new x([t]);
        this.addNode(s), t.parent = s, this.lastNode = t
    }
    oncdataend() {
        this.lastNode = null
    }
    onprocessinginstruction(t, s) {
        const n = new f(t, s);
        this.addNode(n)
    }
    handleCallback(t) {
        if (typeof this.callback == "function") this.callback(t, this.dom);
        else if (t) throw t
    }
    addNode(t) {
        const s = this.tagStack[this.tagStack.length - 1],
            n = s.children[s.children.length - 1];
        this.options.withStartIndices && (t.startIndex = this.parser.startIndex), this.options.withEndIndices && (t.endIndex = this.parser.endIndex), s.children.push(t), n && (t.prev = n, n.next = t), t.parent = s, this.lastNode = null
    }
}
const L = Object.freeze(Object.defineProperty({
    __proto__: null,
    CDATA: x,
    Comment: p,
    DataNode: l,
    Document: c,
    DomHandler: N,
    Element: m,
    Node: u,
    NodeWithChildren: h,
    ProcessingInstruction: f,
    Text: o,
    cloneNode: g,
    default: N,
    hasChildren: D,
    isCDATA: C,
    isComment: S,
    isDirective: I,
    isDocument: w,
    isTag: b,
    isText: v
}, Symbol.toStringTag, {
    value: "Module"
}));
export {
    $ as C, N as D, m as E, A as R, O as S, o as T, v as a, k as b, R as c, j as d, _ as e, P as f, E as g, D as h, S as i, b as j, L as k
};
//# sourceMappingURL=index.DVPf4jiX.min.js.map